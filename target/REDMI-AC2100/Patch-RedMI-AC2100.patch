--- a/package/ipk/luci-app-flowoffload/root/etc/config/flowoffload
+++ b/package/ipk/luci-app-flowoffload/root/etc/config/flowoffload
@@ -1,4 +1,5 @@
 
 config flowoffload
 	option enabled '1'
+	option hw '1'
 

--- a/target/linux/ramips/dts/mt7621.dtsi
+++ b/target/linux/ramips/dts/mt7621.dtsi
@@ -37,6 +37,21 @@
 		compatible = "mti,cpu-interrupt-controller";
 	};
 
+	reserved-memory {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		ranges;
+
+		ramoops@3f00000 {
+			compatible = "ramoops";
+			reg = <0x3f00000 0x80000>;
+
+			record-size = <0x10000>;
+			console-size = <0x10000>;
+			ftrace-size = <0x20000>;
+		};
+	};
+
 	chosen {
 		bootargs = "console=ttyS0,57600";
 	};
@@ -438,6 +453,14 @@
 		clock-names = "nfi_clk";
 	};
 
+	crypto@1e004000 {
+		compatible = "mediatek,mtk-eip93";
+		reg = <0x1e004000 0x1000>;
+
+		interrupt-parent = <&gic>;
+		interrupts = <GIC_SHARED 19 IRQ_TYPE_LEVEL_HIGH>;
+	};
+
 	ethsys: syscon@1e000000 {
 		compatible = "mediatek,mt7621-ethsys",
 			     "syscon";
@@ -463,6 +486,9 @@
 
 		mediatek,ethsys = <&ethsys>;
 
+		pinctrl-names = "default";
+		pinctrl-0 = <&rgmii1_pins &mdio_pins>;
+
 		gmac0: mac@0 {
 			compatible = "mediatek,eth-mac";
 			reg = <0>;

--- a/target/linux/ramips/dts/mt7621_xiaomi_redmi-router-ac2100.dts
+++ b/target/linux/ramips/dts/mt7621_xiaomi_redmi-router-ac2100.dts
@@ -11,7 +11,7 @@
 		led-failsafe = &led_status_amber;
 		led-running = &led_status_white;
 		led-upgrade = &led_status_white;
-		label-mac-device = &gmac0;
+		label-mac-device = &ethernet;
 	};
 
 	leds {

--- a/target/linux/ramips/dts/mt7621_xiaomi_router-ac2100.dtsi
+++ b/target/linux/ramips/dts/mt7621_xiaomi_router-ac2100.dtsi
@@ -1,6 +1,89 @@
 // SPDX-License-Identifier: GPL-2.0-or-later OR MIT
 
-#include "mt7621_xiaomi_nand_128m.dtsi"
+#include "mt7621.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	chosen {
+		bootargs = "console=ttyS0,115200n8";
+	};
+
+	keys {
+		compatible = "gpio-keys";
+
+		reset {
+			label = "reset";
+			gpios = <&gpio 18 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_RESTART>;
+		};
+	};
+};
+
+&nand {
+	status = "okay";
+
+	partitions {
+		compatible = "fixed-partitions";
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {
+			label = "Bootloader";
+			reg = <0x0 0x80000>;
+		};
+
+		partition@80000 {
+			label = "Config";
+			reg = <0x80000 0x40000>;
+		};
+
+		partition@c0000 {
+			label = "Bdata";
+			reg = <0xc0000 0x40000>;
+			read-only;
+		};
+
+		factory: partition@100000 {
+			label = "factory";
+			reg = <0x100000 0x40000>;
+			read-only;
+		};
+
+		partition@140000 {
+			label = "crash";
+			reg = <0x140000 0x40000>;
+		};
+
+		partition@180000 {
+			label = "crash_syslog";
+			reg = <0x180000 0x40000>;
+		};
+
+		partition@1c0000 {
+			label = "reserved0";
+			reg = <0x1c0000 0x40000>;
+			read-only;
+		};
+
+		/* We keep stock xiaomi firmware (kernel0) here */
+		partition@200000 {
+			label = "kernel_stock";
+			reg = <0x200000 0x400000>;
+		};
+
+		partition@600000 {
+			label = "kernel";
+			reg = <0x600000 0x400000>;
+		};
+
+		partition@a00000 {
+			label = "ubi";
+			reg = <0xa00000 0x7580000>;
+		};
+	};
+};
 
 &pcie {
 	status = "okay";
@@ -24,35 +107,19 @@
 	};
 };
 
-&gmac0 {
-	nvmem-cells = <&macaddr_factory_e000>;
-	nvmem-cell-names = "mac-address";
+&ethernet {
+	compatible = "mediatek,ralink-mt7621-eth";
+	mediatek,switch = <&gsw>;
+	mtd-mac-address = <&factory 0xe006>;
 };
 
 &switch0 {
-	ports {
-		port@0 {
-			status = "okay";
-			label = "wan";
-			nvmem-cells = <&macaddr_factory_e006>;
-			nvmem-cell-names = "mac-address";
-		};
-
-		port@2 {
-			status = "okay";
-			label = "lan1";
-		};
-
-		port@3 {
-			status = "okay";
-			label = "lan2";
-		};
+	/delete-property/ compatible;
+	phy-mode = "rgmii";
+};
 
-		port@4 {
-			status = "okay";
-			label = "lan3";
-		};
-	};
+&gsw {
+	compatible = "mediatek,ralink-mt7621-gsw";
 };
 
 &state_default {
@@ -61,17 +128,3 @@
 		function = "gpio";
 	};
 };
-
-&factory {
-	compatible = "nvmem-cells";
-	#address-cells = <1>;
-	#size-cells = <1>;
-
-	macaddr_factory_e000: macaddr@e000 {
-		reg = <0xe000 0x6>;
-	};
-
-	macaddr_factory_e006: macaddr@e006 {
-		reg = <0xe006 0x6>;
-	};
-};

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/esw_rt3050.c
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/esw_rt3050.c
@@ -17,14 +17,11 @@
 #include <linux/kernel.h>
 #include <linux/platform_device.h>
 #include <asm/mach-ralink/ralink_regs.h>
-#include <linux/of_device.h>
 #include <linux/of_irq.h>
 
 #include <linux/switch.h>
-#include <linux/reset.h>
 
 #include "mtk_eth_soc.h"
-#include "esw_rt3050.h"
 
 /* HW limitations for this switch:
  * - No large frame support (PKT_MAX_LEN at most 1536)
@@ -175,6 +172,7 @@
 
 #define RT5350_ESW_REG_PXTPC(_x)	(0x150 + (4 * _x))
 #define RT5350_EWS_REG_LED_POLARITY	0x168
+#define RT5350_RESET_EPHY		BIT(24)
 
 enum {
 	/* Global attributes. */
@@ -217,7 +215,6 @@
 	struct device		*dev;
 	void __iomem		*base;
 	int			irq;
-	struct fe_priv		*priv;
 
 	/* Protects against concurrent register r/w operations. */
 	spinlock_t		reg_rw_lock;
@@ -235,8 +232,6 @@
 	int			led_frequency;
 	struct esw_vlan vlans[RT305X_ESW_NUM_VLANS];
 	struct esw_port ports[RT305X_ESW_NUM_PORTS];
-	struct reset_control	*rst_esw;
-	struct reset_control	*rst_ephy;
 
 };
 
@@ -259,29 +254,6 @@
 	__raw_writel(t | val, esw->base + reg);
 }
 
-static void esw_reset(struct rt305x_esw *esw)
-{
-	if (!esw->rst_esw)
-		return;
-
-	reset_control_assert(esw->rst_esw);
-	usleep_range(60, 120);
-	reset_control_deassert(esw->rst_esw);
-	/* the esw takes long to reset otherwise the board hang */
-	msleep(10);
-}
-
-static void esw_reset_ephy(struct rt305x_esw *esw)
-{
-	if (!esw->rst_ephy)
-		return;
-
-	reset_control_assert(esw->rst_ephy);
-	usleep_range(60, 120);
-	reset_control_deassert(esw->rst_ephy);
-	usleep_range(60, 120);
-}
-
 static void esw_rmw(struct rt305x_esw *esw, unsigned reg,
 		    unsigned long mask, unsigned long val)
 {
@@ -464,8 +436,6 @@
 	u8 port_disable = 0;
 	u8 port_map = RT305X_ESW_PMAP_LLLLLL;
 
-	esw_reset(esw);
-
 	/* vodoo from original driver */
 	esw_w32(esw, 0xC8A07850, RT305X_ESW_REG_FCT0);
 	esw_w32(esw, 0x00000000, RT305X_ESW_REG_SGC2);
@@ -535,7 +505,8 @@
 		esw->ports[i].disable = (port_disable & (1 << i)) != 0;
 
 	if (ralink_soc == RT305X_SOC_RT3352) {
-		esw_reset_ephy(esw);
+		/* reset EPHY */
+		fe_reset(RT5350_RESET_EPHY);
 
 		rt305x_mii_write(esw, 0, 31, 0x8000);
 		for (i = 0; i < 5; i++) {
@@ -585,7 +556,8 @@
 		/* select local register */
 		rt305x_mii_write(esw, 0, 31, 0x8000);
 	} else if (ralink_soc == RT305X_SOC_RT5350) {
-		esw_reset_ephy(esw);
+		/* reset EPHY */
+		fe_reset(RT5350_RESET_EPHY);
 
 		/* set the led polarity */
 		esw_w32(esw, esw->reg_led_polarity & 0x1F,
@@ -642,7 +614,8 @@
 	} else if (ralink_soc == MT762X_SOC_MT7628AN || ralink_soc == MT762X_SOC_MT7688) {
 		int i;
 
-		esw_reset_ephy(esw);
+		/* reset EPHY */
+		fe_reset(RT5350_RESET_EPHY);
 
 		/* set the led polarity */
 		esw_w32(esw, esw->reg_led_polarity & 0x1F,
@@ -738,44 +711,19 @@
 	esw_w32(esw, ~RT305X_ESW_PORT_ST_CHG, RT305X_ESW_REG_IMR);
 }
 
-
-int rt3050_esw_has_carrier(struct fe_priv *priv)
-{
-	struct rt305x_esw *esw = priv->soc->swpriv;
-	u32 link;
-	int i;
-	bool cpuport;
-
-	link = esw_r32(esw, RT305X_ESW_REG_POA);
-	link >>= RT305X_ESW_POA_LINK_SHIFT;
-	cpuport = link & BIT(RT305X_ESW_PORT6);
-	link &= RT305X_ESW_POA_LINK_MASK;
-	for (i = 0; i <= RT305X_ESW_PORT5; i++) {
-		if (priv->link[i] != (link & BIT(i)))
-			dev_info(esw->dev, "port %d link %s\n", i, link & BIT(i) ? "up" : "down");
-		priv->link[i] = link & BIT(i);
-	}
-
-	return !!link && cpuport;
-}
-
 static irqreturn_t esw_interrupt(int irq, void *_esw)
 {
-	struct rt305x_esw *esw = (struct rt305x_esw *) _esw;
+	struct rt305x_esw *esw = (struct rt305x_esw *)_esw;
 	u32 status;
-	int i;
 
 	status = esw_r32(esw, RT305X_ESW_REG_ISR);
 	if (status & RT305X_ESW_PORT_ST_CHG) {
-		if (!esw->priv)
-			goto out;
-		if (rt3050_esw_has_carrier(esw->priv))
-			netif_carrier_on(esw->priv->netdev);
-		else
-			netif_carrier_off(esw->priv->netdev);
-	}
+		u32 link = esw_r32(esw, RT305X_ESW_REG_POA);
 
-out:
+		link >>= RT305X_ESW_POA_LINK_SHIFT;
+		link &= RT305X_ESW_POA_LINK_MASK;
+		dev_info(esw->dev, "link changed 0x%02X\n", link);
+	}
 	esw_w32(esw, status, RT305X_ESW_REG_ISR);
 
 	return IRQ_HANDLED;
@@ -1403,7 +1351,9 @@
 	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	struct device_node *np = pdev->dev.of_node;
 	const __be32 *port_map, *port_disable, *reg_init;
+	struct switch_dev *swdev;
 	struct rt305x_esw *esw;
+	int ret;
 
 	esw = devm_kzalloc(&pdev->dev, sizeof(*esw), GFP_KERNEL);
 	if (!esw)
@@ -1435,74 +1385,6 @@
 	if (reg_init)
 		esw->reg_led_polarity = be32_to_cpu(*reg_init);
 
-	esw->rst_esw = devm_reset_control_get(&pdev->dev, "esw");
-	if (IS_ERR(esw->rst_esw))
-		esw->rst_esw = NULL;
-	esw->rst_ephy = devm_reset_control_get(&pdev->dev, "ephy");
-	if (IS_ERR(esw->rst_ephy))
-		esw->rst_ephy = NULL;
-
-	spin_lock_init(&esw->reg_rw_lock);
-	platform_set_drvdata(pdev, esw);
-
-	return 0;
-}
-
-static int esw_remove(struct platform_device *pdev)
-{
-	struct rt305x_esw *esw = platform_get_drvdata(pdev);
-
-	if (esw) {
-		esw_w32(esw, ~0, RT305X_ESW_REG_IMR);
-		platform_set_drvdata(pdev, NULL);
-	}
-
-	return 0;
-}
-
-static const struct of_device_id ralink_esw_match[] = {
-	{ .compatible = "ralink,rt3050-esw" },
-	{},
-};
-MODULE_DEVICE_TABLE(of, ralink_esw_match);
-
-/* called by the ethernet driver to bound with the switch driver */
-int rt3050_esw_init(struct fe_priv *priv)
-{
-	struct device_node *np = priv->switch_np;
-	struct platform_device *pdev = of_find_device_by_node(np);
-	struct switch_dev *swdev;
-	struct rt305x_esw *esw;
-	const __be32 *rgmii;
-	int ret;
-
-	if (!pdev)
-		return -ENODEV;
-
-	if (!of_device_is_compatible(np, ralink_esw_match->compatible))
-		return -EINVAL;
-
-	esw = platform_get_drvdata(pdev);
-	if (!esw)
-		return -EPROBE_DEFER;
-
-	priv->soc->swpriv = esw;
-	esw->priv = priv;
-
-	esw_hw_init(esw);
-
-	rgmii = of_get_property(np, "ralink,rgmii", NULL);
-	if (rgmii && be32_to_cpu(*rgmii) == 1) {
-		/*
-		 * External switch connected to RGMII interface.
-		 * Unregister the switch device after initialization.
-		 */
-		dev_err(&pdev->dev, "RGMII mode, not exporting switch device.\n");
-		unregister_switch(&esw->swdev);
-		platform_set_drvdata(pdev, NULL);
-		return -ENODEV;
-	}
-
 	swdev = &esw->swdev;
 	swdev->of_node = pdev->dev.of_node;
 	swdev->name = "rt305x-esw";
@@ -1518,19 +1400,53 @@
 		return ret;
 	}
 
+	platform_set_drvdata(pdev, esw);
+
+	spin_lock_init(&esw->reg_rw_lock);
+
+	esw_hw_init(esw);
+
+	reg_init = of_get_property(np, "ralink,rgmii", NULL);
+	if (reg_init && be32_to_cpu(*reg_init) == 1) {
+		/* 
+		 * External switch connected to RGMII interface. 
+		 * Unregister the switch device after initialization. 
+		 */
+		dev_err(&pdev->dev, "RGMII mode, not exporting switch device.\n");
+		unregister_switch(&esw->swdev);
+		platform_set_drvdata(pdev, NULL);
+		return -ENODEV;
+	}
+
 	ret = devm_request_irq(&pdev->dev, esw->irq, esw_interrupt, 0, "esw",
-			esw);
+			       esw);
+
 	if (!ret) {
 		esw_w32(esw, RT305X_ESW_PORT_ST_CHG, RT305X_ESW_REG_ISR);
 		esw_w32(esw, ~RT305X_ESW_PORT_ST_CHG, RT305X_ESW_REG_IMR);
 	}
 
-	dev_info(&pdev->dev, "mediatek esw at 0x%08lx, irq %d initialized\n",
-		   esw->base, esw->irq);
+	return ret;
+}
+
+static int esw_remove(struct platform_device *pdev)
+{
+	struct rt305x_esw *esw = platform_get_drvdata(pdev);
+
+	if (esw) {
+		esw_w32(esw, ~0, RT305X_ESW_REG_IMR);
+		platform_set_drvdata(pdev, NULL);
+	}
 
 	return 0;
 }
 
+static const struct of_device_id ralink_esw_match[] = {
+	{ .compatible = "ralink,rt3050-esw" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ralink_esw_match);
+
 static struct platform_driver esw_driver = {
 	.probe = esw_probe,
 	.remove = esw_remove,

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/esw_rt3050.h
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/esw_rt3050.h
@@ -26,7 +26,4 @@
 static inline void mtk_switch_exit(void) { }
 
 #endif
-
-int rt3050_esw_init(struct fe_priv *priv);
-int rt3050_esw_has_carrier(struct fe_priv *priv);
 #endif

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/gsw_mt7620.c
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/gsw_mt7620.c
@@ -40,7 +40,7 @@
 	struct fe_priv *priv = (struct fe_priv *)_priv;
 	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
 	u32 status;
-	int i, max = (gsw->port4_ephy) ? (4) : (3);
+	int i, max = (gsw->port4 == PORT4_EPHY) ? (4) : (3);
 
 	status = mtk_switch_r32(gsw, GSW_REG_ISR);
 	if (status & PORT_IRQ_ST_CHG)
@@ -61,82 +61,119 @@
 	return IRQ_HANDLED;
 }
 
-static void mt7620_hw_init(struct mt7620_gsw *gsw)
+static int mt7620_mdio_mode(struct device_node *eth_node)
+{
+	struct device_node *phy_node, *mdiobus_node;
+	const __be32 *id;
+	int ret = 0;
+
+	mdiobus_node = of_get_child_by_name(eth_node, "mdio-bus");
+
+	if (mdiobus_node) {
+		if (of_property_read_bool(mdiobus_node, "mediatek,mdio-mode"))
+			ret = 1;
+
+		for_each_child_of_node(mdiobus_node, phy_node) {
+			id = of_get_property(phy_node, "reg", NULL);
+			if (id && (be32_to_cpu(*id) == 0x1f))
+				ret = 1;
+		}
+
+		of_node_put(mdiobus_node);
+	}
+
+	return ret;
+}
+
+static void mt7620_hw_init(struct mt7620_gsw *gsw, int mdio_mode)
 {
 	u32 i;
 	u32 val;
-	u32 is_BGA = (rt_sysc_r32(SYSC_REG_CHIP_REV_ID) >> 16) & 1;
-
-	/* Internal ethernet requires PCIe RC mode */
-	rt_sysc_w32(rt_sysc_r32(SYSC_REG_CFG1) | PCIE_RC_MODE, SYSC_REG_CFG1);
+	u32 is_BGA = (rt_sysc_r32(0x0c) >> 16) & 1;
 
+	rt_sysc_w32(rt_sysc_r32(SYSC_REG_CFG1) | BIT(8), SYSC_REG_CFG1);
 	mtk_switch_w32(gsw, mtk_switch_r32(gsw, GSW_REG_CKGCR) & ~(0x3 << 4), GSW_REG_CKGCR);
 
 	/* Enable MIB stats */
 	mtk_switch_w32(gsw, mtk_switch_r32(gsw, GSW_REG_MIB_CNT_EN) | (1 << 1), GSW_REG_MIB_CNT_EN);
 
-	if (gsw->ephy_disable) {
-		mtk_switch_w32(gsw, mtk_switch_r32(gsw, GSW_REG_GPC1) |
-			(gsw->ephy_base << 16) | (0x1f << 24),
-			GSW_REG_GPC1);
+	if (mdio_mode) {
+		u32 val;
 
-		pr_info("gsw: internal ephy disabled\n");
-	} else if (gsw->ephy_base) {
+		/* turn off ephy and set phy base addr to 12 */
 		mtk_switch_w32(gsw, mtk_switch_r32(gsw, GSW_REG_GPC1) |
-			(gsw->ephy_base << 16),
+			(0x1f << 24) | (0xc << 16),
 			GSW_REG_GPC1);
-		fe_reset(MT7620A_RESET_EPHY);
 
-		pr_info("gsw: ephy base address: %d\n", gsw->ephy_base);
-	}
+		/* set MT7530 central align */
+		val = mt7530_mdio_r32(gsw, 0x7830);
+		val &= ~BIT(0);
+		val |= BIT(1);
+		mt7530_mdio_w32(gsw, 0x7830, val);
+
+		val = mt7530_mdio_r32(gsw, 0x7a40);
+		val &= ~BIT(30);
+		mt7530_mdio_w32(gsw, 0x7a40, val);
 
-	/* global page 4 */
-	_mt7620_mii_write(gsw, gsw->ephy_base + 1, 31, 0x4000);
+		mt7530_mdio_w32(gsw, 0x7a78, 0x855);
+	} else {
 
-	_mt7620_mii_write(gsw, gsw->ephy_base + 1, 17, 0x7444);
-	if (is_BGA)
-		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 19, 0x0114);
-	else
-		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 19, 0x0117);
+		if (gsw->ephy_base) {
+			/* set phy base addr to ephy_base */
+			mtk_switch_w32(gsw, mtk_switch_r32(gsw, GSW_REG_GPC1) |
+				(gsw->ephy_base << 16),
+				GSW_REG_GPC1);
+			fe_reset(BIT(24)); /* Resets the Ethernet PHY block. */
+		}
 
-	_mt7620_mii_write(gsw, gsw->ephy_base + 1, 22, 0x10cf);
-	_mt7620_mii_write(gsw, gsw->ephy_base + 1, 25, 0x6212);
-	_mt7620_mii_write(gsw, gsw->ephy_base + 1, 26, 0x0777);
-	_mt7620_mii_write(gsw, gsw->ephy_base + 1, 29, 0x4000);
-	_mt7620_mii_write(gsw, gsw->ephy_base + 1, 28, 0xc077);
-	_mt7620_mii_write(gsw, gsw->ephy_base + 1, 24, 0x0000);
-
-	/* global page 3 */
-	_mt7620_mii_write(gsw, gsw->ephy_base + 1, 31, 0x3000);
-	_mt7620_mii_write(gsw, gsw->ephy_base + 1, 17, 0x4838);
+		/* global page 4 */
+		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 31, 0x4000);
 
-	/* global page 2 */
-	_mt7620_mii_write(gsw, gsw->ephy_base + 1, 31, 0x2000);
-	if (is_BGA) {
-		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 21, 0x0515);
-		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 22, 0x0053);
-		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 23, 0x00bf);
-		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 24, 0x0aaf);
-		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 25, 0x0fad);
-		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 26, 0x0fc1);
-	} else {
-		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 21, 0x0517);
-		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 22, 0x0fd2);
-		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 23, 0x00bf);
-		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 24, 0x0aab);
-		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 25, 0x00ae);
-		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 26, 0x0fff);
-	}
-	/* global page 1 */
-	_mt7620_mii_write(gsw, gsw->ephy_base + 1, 31, 0x1000);
-	_mt7620_mii_write(gsw, gsw->ephy_base + 1, 17, 0xe7f8);
-
-	/* turn on all PHYs */
-	for (i = 0; i <= 4; i++) {
-		val = _mt7620_mii_read(gsw, gsw->ephy_base + i, MII_BMCR);
-		val &= ~BMCR_PDOWN;
-		val |= BMCR_ANRESTART | BMCR_ANENABLE | BMCR_SPEED100;
-		_mt7620_mii_write(gsw, gsw->ephy_base + i, MII_BMCR, val);
+		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 17, 0x7444);
+		if (is_BGA)
+			_mt7620_mii_write(gsw, gsw->ephy_base + 1, 19, 0x0114);
+		else
+			_mt7620_mii_write(gsw, gsw->ephy_base + 1, 19, 0x0117);
+
+		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 22, 0x10cf);
+		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 25, 0x6212);
+		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 26, 0x0777);
+		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 29, 0x4000);
+		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 28, 0xc077);
+		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 24, 0x0000);
+
+		/* global page 3 */
+		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 31, 0x3000);
+		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 17, 0x4838);
+
+		/* global page 2 */
+		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 31, 0x2000);
+		if (is_BGA) {
+			_mt7620_mii_write(gsw, gsw->ephy_base + 1, 21, 0x0515);
+			_mt7620_mii_write(gsw, gsw->ephy_base + 1, 22, 0x0053);
+			_mt7620_mii_write(gsw, gsw->ephy_base + 1, 23, 0x00bf);
+			_mt7620_mii_write(gsw, gsw->ephy_base + 1, 24, 0x0aaf);
+			_mt7620_mii_write(gsw, gsw->ephy_base + 1, 25, 0x0fad);
+			_mt7620_mii_write(gsw, gsw->ephy_base + 1, 26, 0x0fc1);
+		} else {
+			_mt7620_mii_write(gsw, gsw->ephy_base + 1, 21, 0x0517);
+			_mt7620_mii_write(gsw, gsw->ephy_base + 1, 22, 0x0fd2);
+			_mt7620_mii_write(gsw, gsw->ephy_base + 1, 23, 0x00bf);
+			_mt7620_mii_write(gsw, gsw->ephy_base + 1, 24, 0x0aab);
+			_mt7620_mii_write(gsw, gsw->ephy_base + 1, 25, 0x00ae);
+			_mt7620_mii_write(gsw, gsw->ephy_base + 1, 26, 0x0fff);
+		}
+		/* global page 1 */
+		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 31, 0x1000);
+		_mt7620_mii_write(gsw, gsw->ephy_base + 1, 17, 0xe7f8);
+
+		/* turn on all PHYs */
+		for (i = 0; i <= 4; i++) {
+			val = _mt7620_mii_read(gsw, gsw->ephy_base + i, MII_BMCR);
+			val &= ~BMCR_PDOWN;
+			val |= BMCR_ANRESTART | BMCR_ANENABLE | BMCR_SPEED100;
+			_mt7620_mii_write(gsw, gsw->ephy_base + i, MII_BMCR, val);
+		}
 	}
 
 	/* global page 0 */
@@ -165,8 +202,8 @@
 	mtk_switch_w32(gsw, 0x7f7f7fe0, 0x0010);
 
 	/* setup port 4 */
-	if (gsw->port4_ephy) {
-		val = rt_sysc_r32(SYSC_REG_CFG1);
+	if (gsw->port4 == PORT4_EPHY) {
+		u32 val = rt_sysc_r32(SYSC_REG_CFG1);
 
 		val |= 3 << 14;
 		rt_sysc_w32(val, SYSC_REG_CFG1);
@@ -174,6 +211,12 @@
 		_mt7620_mii_write(gsw, gsw->ephy_base + 4, 4, 0x05e1);
 		_mt7620_mii_write(gsw, gsw->ephy_base + 4, 16, 0x1313);
 		pr_info("gsw: setting port4 to ephy mode\n");
+	} else if (!mdio_mode) {
+		u32 val = rt_sysc_r32(SYSC_REG_CFG1);
+
+		val &= ~(3 << 14);
+		rt_sysc_w32(val, SYSC_REG_CFG1);
+		pr_info("gsw: setting port4 to gmac mode\n");
 	}
 }
 
@@ -185,13 +228,9 @@
 
 int mtk_gsw_init(struct fe_priv *priv)
 {
-	struct device_node *eth_node = priv->dev->of_node;
-	struct device_node *phy_node, *mdiobus_node;
 	struct device_node *np = priv->switch_np;
 	struct platform_device *pdev = of_find_device_by_node(np);
 	struct mt7620_gsw *gsw;
-	const __be32 *id;
-	u8 val;
 
 	if (!pdev)
 		return -ENODEV;
@@ -202,27 +241,7 @@
 	gsw = platform_get_drvdata(pdev);
 	priv->soc->swpriv = gsw;
 
-	gsw->ephy_disable = of_property_read_bool(np, "mediatek,ephy-disable");
-
-	mdiobus_node = of_get_child_by_name(eth_node, "mdio-bus");
-	if (mdiobus_node) {
-		for_each_child_of_node(mdiobus_node, phy_node) {
-			id = of_get_property(phy_node, "reg", NULL);
-			if (id && (be32_to_cpu(*id) == 0x1f))
-				gsw->ephy_disable = true;
-		}
-
-		of_node_put(mdiobus_node);
-	}
-
-	gsw->port4_ephy = !of_property_read_bool(np, "mediatek,port4-gmac");
-
-	if (of_property_read_u8(np, "mediatek,ephy-base", &val) == 0)
-		gsw->ephy_base = val;
-	else
-		gsw->ephy_base = 0;
-
-	mt7620_hw_init(gsw);
+	mt7620_hw_init(gsw, mt7620_mdio_mode(priv->dev->of_node));
 
 	if (gsw->irq) {
 		request_irq(gsw->irq, gsw_interrupt_mt7620, 0,
@@ -236,7 +255,10 @@
 static int mt7620_gsw_probe(struct platform_device *pdev)
 {
 	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	const char *port4 = NULL;
 	struct mt7620_gsw *gsw;
+	struct device_node *np = pdev->dev.of_node;
+	u16 val;
 
 	gsw = devm_kzalloc(&pdev->dev, sizeof(struct mt7620_gsw), GFP_KERNEL);
 	if (!gsw)
@@ -248,6 +270,19 @@
 
 	gsw->dev = &pdev->dev;
 
+	of_property_read_string(np, "mediatek,port4", &port4);
+	if (port4 && !strcmp(port4, "ephy"))
+		gsw->port4 = PORT4_EPHY;
+	else if (port4 && !strcmp(port4, "gmac"))
+		gsw->port4 = PORT4_EXT;
+	else
+		gsw->port4 = PORT4_EPHY;
+
+	if (of_property_read_u16(np, "mediatek,ephy-base-address", &val) == 0)
+		gsw->ephy_base = val;
+	else
+		gsw->ephy_base = 0;
+
 	gsw->irq = platform_get_irq(pdev, 0);
 
 	platform_set_drvdata(pdev, gsw);

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/gsw_mt7620.h
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/gsw_mt7620.h
@@ -17,7 +17,11 @@
 
 #define GSW_REG_PHY_TIMEOUT	(5 * HZ)
 
+#ifdef CONFIG_SOC_MT7621
+#define MT7620A_GSW_REG_PIAC	0x0004
+#else
 #define MT7620A_GSW_REG_PIAC	0x7004
+#endif
 
 #define GSW_NUM_VLANS		16
 #define GSW_NUM_VIDS		4096
@@ -55,13 +59,17 @@
 
 #define SYSC_REG_CHIP_REV_ID	0x0c
 #define SYSC_REG_CFG1		0x14
-#define PCIE_RC_MODE		BIT(8)
+#define RST_CTRL_MCM		BIT(2)
 #define SYSC_PAD_RGMII2_MDIO	0x58
 #define SYSC_GPIO_MODE		0x60
 
 #define PORT_IRQ_ST_CHG		0x7f
 
+#ifdef CONFIG_SOC_MT7621
+#define ESW_PHY_POLLING		0x0000
+#else
 #define ESW_PHY_POLLING		0x7000
+#endif
 
 #define	PMCR_IPG		BIT(18)
 #define	PMCR_MAC_MODE		BIT(16)
@@ -88,12 +96,16 @@
 	GSW_ATTR_PORT_UNTAG,
 };
 
+enum {
+	PORT4_EPHY = 0,
+	PORT4_EXT,
+};
+
 struct mt7620_gsw {
 	struct device		*dev;
 	void __iomem		*base;
 	int			irq;
-	bool			ephy_disable;
-	bool			port4_ephy;
+	int			port4;
 	unsigned long int	autopoll;
 	u16			ephy_base;
 };

--- /dev/null
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/gsw_mt7621.c
@@ -0,0 +1,297 @@
+/*   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; version 2 of the License
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+ *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+ *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+
+#include <ralink_regs.h>
+
+#include "mtk_eth_soc.h"
+#include "gsw_mt7620.h"
+
+void mtk_switch_w32(struct mt7620_gsw *gsw, u32 val, unsigned reg)
+{
+	iowrite32(val, gsw->base + reg);
+}
+
+u32 mtk_switch_r32(struct mt7620_gsw *gsw, unsigned reg)
+{
+	return ioread32(gsw->base + reg);
+}
+
+static irqreturn_t gsw_interrupt_mt7621(int irq, void *_priv)
+{
+	struct fe_priv *priv = (struct fe_priv *)_priv;
+	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
+	u32 reg, i;
+
+	reg = mt7530_mdio_r32(gsw, 0x700c);
+	mt7530_mdio_w32(gsw, 0x700c, reg);
+
+	for (i = 0; i < 5; i++)
+		if (reg & BIT(i)) {
+			unsigned int link;
+
+			link = mt7530_mdio_r32(gsw,
+					       0x3008 + (i * 0x100)) & 0x1;
+
+			if (link != priv->link[i]) {
+				priv->link[i] = link;
+				if (link)
+					netdev_info(priv->netdev,
+						    "port %d link up\n", i);
+				else
+					netdev_info(priv->netdev,
+						    "port %d link down\n", i);
+			}
+		}
+
+	mt7620_handle_carrier(priv);
+
+	return IRQ_HANDLED;
+}
+
+static void mt7621_hw_init(struct mt7620_gsw *gsw, struct device_node *np)
+{
+	u32 i;
+	u32 val;
+
+	/* wardware reset the switch */
+	fe_reset(RST_CTRL_MCM);
+	mdelay(10);
+
+	/* reduce RGMII2 PAD driving strength */
+	rt_sysc_m32(3 << 4, 0, SYSC_PAD_RGMII2_MDIO);
+
+	/* gpio mux - RGMII1=Normal mode */
+	rt_sysc_m32(BIT(14), 0, SYSC_GPIO_MODE);
+
+	/* set GMAC1 RGMII mode */
+	rt_sysc_m32(3 << 12, 0, SYSC_REG_CFG1);
+
+	/* enable MDIO to control MT7530 */
+	rt_sysc_m32(3 << 12, 0, SYSC_GPIO_MODE);
+
+	/* turn off all PHYs */
+	for (i = 0; i <= 4; i++) {
+		val = _mt7620_mii_read(gsw, i, 0x0);
+		val |= BIT(11);
+		_mt7620_mii_write(gsw, i, 0x0, val);
+	}
+
+	/* reset the switch */
+	mt7530_mdio_w32(gsw, 0x7000, 0x3);
+	usleep_range(10, 20);
+
+	if ((rt_sysc_r32(SYSC_REG_CHIP_REV_ID) & 0xFFFF) == 0x0101) {
+		/* (GE1, Force 1000M/FD, FC ON, MAX_RX_LENGTH 1536) */
+		mtk_switch_w32(gsw, 0x2305e30b, GSW_REG_MAC_P0_MCR);
+		mt7530_mdio_w32(gsw, 0x3600, 0x5e30b);
+	} else {
+		/* (GE1, Force 1000M/FD, FC ON, MAX_RX_LENGTH 1536) */
+		mtk_switch_w32(gsw, 0x2305e33b, GSW_REG_MAC_P0_MCR);
+		mt7530_mdio_w32(gsw, 0x3600, 0x5e33b);
+	}
+
+	/* (GE2, Link down) */
+	mtk_switch_w32(gsw, 0x8000, GSW_REG_MAC_P1_MCR);
+
+	/* Set switch max RX frame length to 2k */
+	mt7530_mdio_w32(gsw, GSW_REG_GMACCR, 0x3F0B);
+
+	/* Enable Port 6, P5 as GMAC5, P5 disable */
+	val = mt7530_mdio_r32(gsw, 0x7804);
+	val &= ~BIT(8);
+	val |= BIT(6) | BIT(13) | BIT(16);
+	mt7530_mdio_w32(gsw, 0x7804, val);
+
+	val = rt_sysc_r32(0x10);
+	val = (val >> 6) & 0x7;
+	if (val >= 6) {
+		/* 25Mhz Xtal - do nothing */
+	} else if (val >= 3) {
+		/* 40Mhz */
+
+		/* disable MT7530 core clock */
+		_mt7620_mii_write(gsw, 0, 13, 0x1f);
+		_mt7620_mii_write(gsw, 0, 14, 0x410);
+		_mt7620_mii_write(gsw, 0, 13, 0x401f);
+		_mt7620_mii_write(gsw, 0, 14, 0x0);
+
+		/* disable MT7530 PLL */
+		_mt7620_mii_write(gsw, 0, 13, 0x1f);
+		_mt7620_mii_write(gsw, 0, 14, 0x40d);
+		_mt7620_mii_write(gsw, 0, 13, 0x401f);
+		_mt7620_mii_write(gsw, 0, 14, 0x2020);
+
+		/* for MT7530 core clock = 500Mhz */
+		_mt7620_mii_write(gsw, 0, 13, 0x1f);
+		_mt7620_mii_write(gsw, 0, 14, 0x40e);
+		_mt7620_mii_write(gsw, 0, 13, 0x401f);
+		_mt7620_mii_write(gsw, 0, 14, 0x119);
+
+		/* enable MT7530 PLL */
+		_mt7620_mii_write(gsw, 0, 13, 0x1f);
+		_mt7620_mii_write(gsw, 0, 14, 0x40d);
+		_mt7620_mii_write(gsw, 0, 13, 0x401f);
+		_mt7620_mii_write(gsw, 0, 14, 0x2820);
+
+		usleep_range(20, 40);
+
+		/* enable MT7530 core clock */
+		_mt7620_mii_write(gsw, 0, 13, 0x1f);
+		_mt7620_mii_write(gsw, 0, 14, 0x410);
+		_mt7620_mii_write(gsw, 0, 13, 0x401f);
+	} else {
+		/* 20Mhz Xtal - TODO */
+	}
+
+	/* RGMII */
+	_mt7620_mii_write(gsw, 0, 14, 0x1);
+
+	/* set MT7530 central align */
+	val = mt7530_mdio_r32(gsw, 0x7830);
+	val &= ~BIT(0);
+	val |= BIT(1);
+	mt7530_mdio_w32(gsw, 0x7830, val);
+	val = mt7530_mdio_r32(gsw, 0x7a40);
+	val &= ~BIT(30);
+	mt7530_mdio_w32(gsw, 0x7a40, val);
+	mt7530_mdio_w32(gsw, 0x7a78, 0x855);
+
+	/* delay setting for 10/1000M */
+	mt7530_mdio_w32(gsw, 0x7b00, 0x102);
+	mt7530_mdio_w32(gsw, 0x7b04, 0x14);
+
+	/* lower Tx Driving*/
+	mt7530_mdio_w32(gsw, 0x7a54, 0x44);
+	mt7530_mdio_w32(gsw, 0x7a5c, 0x44);
+	mt7530_mdio_w32(gsw, 0x7a64, 0x44);
+	mt7530_mdio_w32(gsw, 0x7a6c, 0x44);
+	mt7530_mdio_w32(gsw, 0x7a74, 0x44);
+	mt7530_mdio_w32(gsw, 0x7a7c, 0x44);
+
+	/* Disable EEE */
+	for (i = 0; i <= 4; i++) {
+		_mt7620_mii_write(gsw, i, 13, 0x7);
+		_mt7620_mii_write(gsw, i, 14, 0x3C);
+		_mt7620_mii_write(gsw, i, 13, 0x4007);
+		_mt7620_mii_write(gsw, i, 14, 0x0);
+	}
+
+	/* Disable EEE 10Base-Te */
+	for (i = 0; i <= 4; i++) {
+		_mt7620_mii_write(gsw, i, 13, 0x1f);
+		_mt7620_mii_write(gsw, i, 14, 0x027b);
+		_mt7620_mii_write(gsw, i, 13, 0x401f);
+		_mt7620_mii_write(gsw, i, 14, 0x1177);
+	}
+
+	/* turn on all PHYs */
+	for (i = 0; i <= 4; i++) {
+		val = _mt7620_mii_read(gsw, i, 0);
+		val &= ~BIT(11);
+		_mt7620_mii_write(gsw, i, 0, val);
+	}
+
+	/* enable irq */
+	mt7530_mdio_w32(gsw, 0x7008, 0x1f);
+	val = mt7530_mdio_r32(gsw, 0x7808);
+	val |= 3 << 16;
+	mt7530_mdio_w32(gsw, 0x7808, val);
+}
+
+static const struct of_device_id mediatek_gsw_match[] = {
+	{ .compatible = "mediatek,ralink-mt7621-gsw" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mediatek_gsw_match);
+
+int mtk_gsw_init(struct fe_priv *priv)
+{
+	struct device_node *np = priv->switch_np;
+	struct platform_device *pdev = of_find_device_by_node(np);
+	struct mt7620_gsw *gsw;
+
+	if (!pdev)
+		return -ENODEV;
+
+	if (!of_device_is_compatible(np, mediatek_gsw_match->compatible))
+		return -EINVAL;
+
+	gsw = platform_get_drvdata(pdev);
+	priv->soc->swpriv = gsw;
+
+	if (gsw->irq) {
+		request_irq(gsw->irq, gsw_interrupt_mt7621, 0,
+			    "gsw", priv);
+		disable_irq(gsw->irq);
+	}
+
+	mt7621_hw_init(gsw, np);
+
+	if (gsw->irq)
+		enable_irq(gsw->irq);
+
+	return 0;
+}
+
+static int mt7621_gsw_probe(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	struct mt7620_gsw *gsw;
+
+	gsw = devm_kzalloc(&pdev->dev, sizeof(struct mt7620_gsw), GFP_KERNEL);
+	if (!gsw)
+		return -ENOMEM;
+
+	gsw->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(gsw->base))
+		return PTR_ERR(gsw->base);
+
+	gsw->dev = &pdev->dev;
+	gsw->irq = platform_get_irq(pdev, 0);
+
+	platform_set_drvdata(pdev, gsw);
+
+	return 0;
+}
+
+static int mt7621_gsw_remove(struct platform_device *pdev)
+{
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver gsw_driver = {
+	.probe = mt7621_gsw_probe,
+	.remove = mt7621_gsw_remove,
+	.driver = {
+		.name = "ralink-mt7621-gsw",
+		.owner = THIS_MODULE,
+		.of_match_table = mediatek_gsw_match,
+	},
+};
+
+module_platform_driver(gsw_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("John Crispin <blogic@openwrt.org>");
+MODULE_DESCRIPTION("GBit switch driver for Mediatek MT7621 SoC");
+MODULE_VERSION(MTK_FE_DRV_VERSION);

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/Kconfig
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/Kconfig
@@ -27,15 +27,23 @@
 	bool "MT7620"
 	depends on MIPS && SOC_MT7620
 
+config NET_RALINK_MT7621
+	bool "MT7621"
+	depends on MIPS && SOC_MT7621
+
 endchoice
 
+config NET_RALINK_OFFLOAD
+	def_bool NET_RALINK_SOC
+	depends on NET_RALINK_MT7621
+
 config NET_RALINK_HW_QOS
 	def_bool NET_RALINK_SOC
 	depends on NET_RALINK_MT7623
 
 config NET_RALINK_MDIO
 	def_bool NET_RALINK_SOC
-	depends on (NET_RALINK_RT2880 || NET_RALINK_RT3883 || NET_RALINK_MT7620)
+	depends on (NET_RALINK_RT2880 || NET_RALINK_RT3883 || NET_RALINK_MT7620 || NET_RALINK_MT7621)
 	select PHYLIB
 
 config NET_RALINK_MDIO_RT2880
@@ -45,7 +53,7 @@
 
 config NET_RALINK_MDIO_MT7620
 	def_bool NET_RALINK_SOC
-	depends on NET_RALINK_MT7620
+	depends on (NET_RALINK_MT7620 || NET_RALINK_MT7621)
 	select NET_RALINK_MDIO
 
 config NET_RALINK_ESW_RT3050
@@ -55,4 +63,8 @@
 config NET_RALINK_GSW_MT7620
 	def_tristate NET_RALINK_SOC
 	depends on NET_RALINK_MT7620
+
+config NET_RALINK_GSW_MT7621
+	def_tristate NET_RALINK_SOC
+	depends on NET_RALINK_MT7621
 endif

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/Makefile
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/Makefile
@@ -8,11 +8,15 @@
 ralink-eth-$(CONFIG_NET_RALINK_MDIO_RT2880)	+= mdio_rt2880.o
 ralink-eth-$(CONFIG_NET_RALINK_MDIO_MT7620)	+= mdio_mt7620.o
 
+ralink-eth-$(CONFIG_NET_RALINK_OFFLOAD)	+= mtk_offload.o mtk_debugfs.o
+
 ralink-eth-$(CONFIG_NET_RALINK_RT2880)	+= soc_rt2880.o
 ralink-eth-$(CONFIG_NET_RALINK_RT3050)	+= soc_rt3050.o
 ralink-eth-$(CONFIG_NET_RALINK_RT3883)	+= soc_rt3883.o
 ralink-eth-$(CONFIG_NET_RALINK_MT7620)	+= soc_mt7620.o
+ralink-eth-$(CONFIG_NET_RALINK_MT7621)	+= soc_mt7621.o
 
 obj-$(CONFIG_NET_RALINK_ESW_RT3050)		+= esw_rt3050.o
 obj-$(CONFIG_NET_RALINK_GSW_MT7620)		+= gsw_mt7620.o mt7530.o
+obj-$(CONFIG_NET_RALINK_GSW_MT7621)		+= gsw_mt7621.o mt7530.o
 obj-$(CONFIG_NET_RALINK_SOC)			+= ralink-eth.o

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/mdio.c
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/mdio.c
@@ -97,8 +97,13 @@
 		return -ENODEV;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	phydev->supported &= PHY_GBIT_FEATURES;
+	phydev->advertising = phydev->supported;
+#else
 	phy_set_max_speed(phydev, SPEED_1000);
 	linkmode_copy(phydev->advertising, phydev->supported);
+#endif
 	phydev->no_auto_carrier_off = 1;
 
 	dev_info(priv->dev,
@@ -120,11 +125,17 @@
 	phy->speed = 0;
 	phy->duplex = 0;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	phy->supported &= IS_ENABLED(CONFIG_NET_RALINK_MDIO_MT7620) ?
+			PHY_GBIT_FEATURES : PHY_BASIC_FEATURES;
+	phy->advertising = phy->supported | ADVERTISED_Autoneg;
+#else
 	phy_set_max_speed(phy, IS_ENABLED(CONFIG_NET_RALINK_MDIO_MT7620) ?
 				       SPEED_1000 :
 				       SPEED_100);
 	linkmode_copy(phy->advertising, phy->supported);
 	linkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, phy->advertising);
+#endif
 
 	phy_start_aneg(phy);
 }
@@ -232,8 +243,7 @@
 	mii_np = of_get_child_by_name(priv->dev->of_node, "mdio-bus");
 	if (!mii_np) {
 		dev_err(priv->dev, "no %s child node found", "mdio-bus");
-		err = 0;
-		goto err_no_bus;
+		return -ENODEV;
 	}
 
 	if (!of_device_is_available(mii_np)) {
@@ -265,8 +275,6 @@
 	kfree(priv->mii_bus);
 err_put_node:
 	of_node_put(mii_np);
-err_no_bus:
-	dev_err(priv->dev, "%s disabled", "mdio-bus");
 	priv->mii_bus = NULL;
 	return err;
 }

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/mt7530.c
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/mt7530.c
@@ -31,21 +31,25 @@
 #include <linux/lockdep.h>
 #include <linux/workqueue.h>
 #include <linux/of_device.h>
-#include <asm/byteorder.h>
 
 #include "mt7530.h"
 
 #define MT7530_CPU_PORT		6
 #define MT7530_NUM_PORTS	8
+#ifdef CONFIG_SOC_MT7621
+#define MT7530_NUM_VLANS	4095
+#else
 #define MT7530_NUM_VLANS	16
+#endif
 #define MT7530_MAX_VID		4095
 #define MT7530_MIN_VID		0
-#define MT7530_NUM_ARL_RECORDS 2048
-#define ARL_LINE_LENGTH		30
 
 #define MT7530_PORT_MIB_TXB_ID	2	/* TxGOC */
 #define MT7530_PORT_MIB_RXB_ID	6	/* RxGOC */
 
+#define MT7621_PORT_MIB_TXB_ID	18	/* TxByte */
+#define MT7621_PORT_MIB_RXB_ID	37	/* RxByte */
+
 /* registers */
 #define REG_ESW_WT_MAC_MFC		0x10
 
@@ -57,20 +61,6 @@
 #define REG_ESW_VLAN_VAWD2		0x98
 #define REG_ESW_VLAN_VTIM(x)	(0x100 + 4 * ((x) / 2))
 
-#define REG_ESW_WT_MAC_ATC  0x80
-#define REG_ESW_TABLE_ATRD  0x8C
-#define REG_ESW_TABLE_TSRA1 0x84
-#define REG_ESW_TABLE_TSRA2 0x88
-
-#define REG_MAC_ATC_START  0x8004
-#define REG_MAC_ATC_NEXT   0x8005
-
-#define REG_MAC_ATC_BUSY      0x8000U
-#define REG_MAC_ATC_SRCH_HIT  0x2000U
-#define REG_MAC_ATC_SRCH_END  0x4000U
-#define REG_ATRD_VALID        0xff000000U
-#define REG_ATRD_PORT_MASK    0xff0U
-
 #define REG_ESW_VLAN_VAWD1_IVL_MAC	BIT(30)
 #define REG_ESW_VLAN_VAWD1_VTAG_EN	BIT(28)
 #define REG_ESW_VLAN_VAWD1_VALID	BIT(0)
@@ -152,6 +142,50 @@
 	MIB_DESC(1, MT7620_MIB_STATS_PORT_REPC2N, "RxEPC2")
 };
 
+static const struct mt7xxx_mib_desc mt7621_mibs[] = {
+	MIB_DESC(1, MT7621_STATS_TDPC, "TxDrop"),
+	MIB_DESC(1, MT7621_STATS_TCRC, "TxCRC"),
+	MIB_DESC(1, MT7621_STATS_TUPC, "TxUni"),
+	MIB_DESC(1, MT7621_STATS_TMPC, "TxMulti"),
+	MIB_DESC(1, MT7621_STATS_TBPC, "TxBroad"),
+	MIB_DESC(1, MT7621_STATS_TCEC, "TxCollision"),
+	MIB_DESC(1, MT7621_STATS_TSCEC, "TxSingleCol"),
+	MIB_DESC(1, MT7621_STATS_TMCEC, "TxMultiCol"),
+	MIB_DESC(1, MT7621_STATS_TDEC, "TxDefer"),
+	MIB_DESC(1, MT7621_STATS_TLCEC, "TxLateCol"),
+	MIB_DESC(1, MT7621_STATS_TXCEC, "TxExcCol"),
+	MIB_DESC(1, MT7621_STATS_TPPC, "TxPause"),
+	MIB_DESC(1, MT7621_STATS_TL64PC, "Tx64Byte"),
+	MIB_DESC(1, MT7621_STATS_TL65PC, "Tx65Byte"),
+	MIB_DESC(1, MT7621_STATS_TL128PC, "Tx128Byte"),
+	MIB_DESC(1, MT7621_STATS_TL256PC, "Tx256Byte"),
+	MIB_DESC(1, MT7621_STATS_TL512PC, "Tx512Byte"),
+	MIB_DESC(1, MT7621_STATS_TL1024PC, "Tx1024Byte"),
+	MIB_DESC(2, MT7621_STATS_TOC, "TxByte"),
+	MIB_DESC(1, MT7621_STATS_RDPC, "RxDrop"),
+	MIB_DESC(1, MT7621_STATS_RFPC, "RxFiltered"),
+	MIB_DESC(1, MT7621_STATS_RUPC, "RxUni"),
+	MIB_DESC(1, MT7621_STATS_RMPC, "RxMulti"),
+	MIB_DESC(1, MT7621_STATS_RBPC, "RxBroad"),
+	MIB_DESC(1, MT7621_STATS_RAEPC, "RxAlignErr"),
+	MIB_DESC(1, MT7621_STATS_RCEPC, "RxCRC"),
+	MIB_DESC(1, MT7621_STATS_RUSPC, "RxUnderSize"),
+	MIB_DESC(1, MT7621_STATS_RFEPC, "RxFragment"),
+	MIB_DESC(1, MT7621_STATS_ROSPC, "RxOverSize"),
+	MIB_DESC(1, MT7621_STATS_RJEPC, "RxJabber"),
+	MIB_DESC(1, MT7621_STATS_RPPC, "RxPause"),
+	MIB_DESC(1, MT7621_STATS_RL64PC, "Rx64Byte"),
+	MIB_DESC(1, MT7621_STATS_RL65PC, "Rx65Byte"),
+	MIB_DESC(1, MT7621_STATS_RL128PC, "Rx128Byte"),
+	MIB_DESC(1, MT7621_STATS_RL256PC, "Rx256Byte"),
+	MIB_DESC(1, MT7621_STATS_RL512PC, "Rx512Byte"),
+	MIB_DESC(1, MT7621_STATS_RL1024PC, "Rx1024Byte"),
+	MIB_DESC(2, MT7621_STATS_ROC, "RxByte"),
+	MIB_DESC(1, MT7621_STATS_RDPC_CTRL, "RxCtrlDrop"),
+	MIB_DESC(1, MT7621_STATS_RDPC_ING, "RxIngDrop"),
+	MIB_DESC(1, MT7621_STATS_RDPC_ARL, "RxARLDrop")
+};
+
 enum {
 	/* Global attributes. */
 	MT7530_ATTR_ENABLE_VLAN,
@@ -178,7 +212,6 @@
 	bool			global_vlan_enable;
 	struct mt7530_vlan_entry	vlan_entries[MT7530_NUM_VLANS];
 	struct mt7530_port_entry	port_entries[MT7530_NUM_PORTS];
-	char arl_buf[MT7530_NUM_ARL_RECORDS * ARL_LINE_LENGTH + 1];
 };
 
 struct mt7530_mapping {
@@ -464,6 +497,14 @@
 }
 
 static int
+mt7621_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
+		struct switch_val *val)
+{
+	val->value.i = val->port_vlan;
+	return 0;
+}
+
+static int
 mt7530_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
 		struct switch_val *val)
 {
@@ -555,6 +596,7 @@
 	int port;
 	u32 val;
 
+#ifndef CONFIG_SOC_MT7621
 	/* vid of vlan */
 	val = mt7530_r32(priv, REG_ESW_VLAN_VTIM(vlan));
 	if (vlan % 2 == 0) {
@@ -565,6 +607,7 @@
 		val |= (vid << 12);
 	}
 	mt7530_w32(priv, REG_ESW_VLAN_VTIM(vlan), val);
+#endif
 
 	/* vlan port membership */
 	if (ports)
@@ -585,7 +628,11 @@
 	mt7530_w32(priv, REG_ESW_VLAN_VAWD2, val);
 
 	/* write to vlan table */
+#ifdef CONFIG_SOC_MT7621
+	mt7530_vtcr(priv, 1, vid);
+#else
 	mt7530_vtcr(priv, 1, vlan);
+#endif
 }
 
 static int
@@ -738,6 +785,53 @@
 	return 0;
 }
 
+static u64 get_mib_counter(struct mt7530_priv *priv, int i, int port)
+{
+	unsigned int port_base;
+	u64 lo;
+
+	port_base = MT7621_MIB_COUNTER_BASE +
+		    MT7621_MIB_COUNTER_PORT_OFFSET * port;
+
+	lo = mt7530_r32(priv, port_base + mt7621_mibs[i].offset);
+	if (mt7621_mibs[i].size == 2) {
+		u64 hi;
+
+		hi = mt7530_r32(priv, port_base + mt7621_mibs[i].offset + 4);
+		lo |= hi << 32;
+	}
+
+	return lo;
+}
+
+static int mt7621_sw_get_port_mib(struct switch_dev *dev,
+				  const struct switch_attr *attr,
+				  struct switch_val *val)
+{
+	static char buf[4096];
+	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+	int i, len = 0;
+
+	if (val->port_vlan >= MT7530_NUM_PORTS)
+		return -EINVAL;
+
+	len += snprintf(buf + len, sizeof(buf) - len,
+			"Port %d MIB counters\n", val->port_vlan);
+
+	for (i = 0; i < ARRAY_SIZE(mt7621_mibs); ++i) {
+		u64 counter;
+		len += snprintf(buf + len, sizeof(buf) - len,
+				"%-11s: ", mt7621_mibs[i].name);
+		counter = get_mib_counter(priv, i, val->port_vlan);
+		len += snprintf(buf + len, sizeof(buf) - len, "%llu\n",
+				counter);
+	}
+
+	val->value.s = buf;
+	val->len = len;
+	return 0;
+}
+
 static u64 get_mib_counter_7620(struct mt7530_priv *priv, int i)
 {
 	return mt7530_r32(priv, MT7620_MIB_COUNTER_BASE + mt7620_mibs[i].offset);
@@ -775,100 +869,6 @@
 	return 0;
 }
 
-static char *mt7530_print_arl_table_row(u32 atrd,
-					u32 mac1,
-					u32 mac2,
-					char *buf,
-					size_t *size)
-{
-	int ret;
-	size_t port;
-	size_t i;
-	u8 port_map;
-	u8 mac[ETH_ALEN];
-
-	mac1 = ntohl(mac1);
-	mac2 = ntohl(mac2);
-	port_map = (u8)((atrd & REG_ATRD_PORT_MASK) >> 4);
-	memcpy(mac, &mac1, sizeof(mac1));
-	memcpy(mac + sizeof(mac1), &mac2, sizeof(mac) - sizeof(mac1));
-	for (port = 0, i = 1; port < MT7530_NUM_PORTS; ++port, i <<= 1) {
-		if (port_map & i) {
-			ret = snprintf(buf, *size, "Port %d: MAC %pM\n", port, mac);
-			if (ret >= *size || ret <= 0) {
-				*buf = 0;
-				buf = NULL;
-				goto out;
-			}
-			buf += ret;
-			*size = *size - ret;
-		}
-	}
-out:
-	return buf;
-}
-
-static int mt7530_get_arl_table(struct switch_dev *dev,
-				const struct switch_attr *attr,
-				struct switch_val *val)
-{
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-	char *buf = priv->arl_buf;
-	size_t size = sizeof(priv->arl_buf);
-	size_t count = 0;
-	size_t retry_times = 100;
-	int ret;
-	u32 atc;
-
-	ret = snprintf(buf, size, "address resolution table\n");
-	if (ret >= size || ret <= 0) {
-		priv->arl_buf[0] = 0;
-		goto out;
-	}
-	buf += ret;
-	size = size - ret;
-
-	mt7530_w32(priv, REG_ESW_WT_MAC_ATC, REG_MAC_ATC_START);
-
-	do {
-		atc = mt7530_r32(priv, REG_ESW_WT_MAC_ATC);
-		if (atc & REG_MAC_ATC_SRCH_HIT && !(atc & REG_MAC_ATC_BUSY)) {
-			u32 atrd;
-
-			++count;
-			atrd = mt7530_r32(priv, REG_ESW_TABLE_ATRD);
-			if (atrd & REG_ATRD_VALID) {
-				u32 mac1;
-				u32 mac2;
-
-				mac1 = mt7530_r32(priv, REG_ESW_TABLE_TSRA1);
-				mac2 = mt7530_r32(priv, REG_ESW_TABLE_TSRA2);
-
-				if (!(atc & REG_MAC_ATC_SRCH_END))
-					mt7530_w32(priv, REG_ESW_WT_MAC_ATC, REG_MAC_ATC_NEXT);
-
-				buf = mt7530_print_arl_table_row(atrd, mac1, mac2, buf, &size);
-				if (!buf) {
-					pr_warn("%s: too many addresses\n", __func__);
-					goto out;
-				}
-			} else if (!(atc & REG_MAC_ATC_SRCH_END)) {
-				mt7530_w32(priv, REG_ESW_WT_MAC_ATC, REG_MAC_ATC_NEXT);
-			}
-		} else {
-			--retry_times;
-			usleep_range(1000, 5000);
-		}
-	} while (!(atc & REG_MAC_ATC_SRCH_END) &&
-		 count < MT7530_NUM_ARL_RECORDS &&
-		 retry_times > 0);
-out:
-	val->value.s = priv->arl_buf;
-	val->len = strlen(priv->arl_buf);
-
-	return 0;
-}
-
 static int mt7530_sw_get_port_mib(struct switch_dev *dev,
 				  const struct switch_attr *attr,
 				  struct switch_val *val)
@@ -911,6 +911,20 @@
 	return 0;
 }
 
+static int mt7621_get_port_stats(struct switch_dev *dev, int port,
+					struct switch_port_stats *stats)
+{
+	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
+
+	if (port < 0 || port >= MT7530_NUM_PORTS)
+		return -EINVAL;
+
+	stats->tx_bytes = get_mib_counter(priv, MT7621_PORT_MIB_TXB_ID, port);
+	stats->rx_bytes = get_mib_counter(priv, MT7621_PORT_MIB_RXB_ID, port);
+
+	return 0;
+}
+
 static const struct switch_attr mt7530_global[] = {
 	{
 		.type = SWITCH_TYPE_INT,
@@ -934,12 +948,40 @@
 		.get = mt7530_get_mirror_monitor_port,
 		.max = MT7530_NUM_PORTS - 1
 	},
+};
+
+static const struct switch_attr mt7621_port[] = {
 	{
 		.type = SWITCH_TYPE_STRING,
-		.name = "arl_table",
-		.description = "Get ARL table",
+		.name = "mib",
+		.description = "Get MIB counters for port",
+		.get = mt7621_sw_get_port_mib,
 		.set = NULL,
-		.get = mt7530_get_arl_table,
+	}, {
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_mirror_rx",
+		.description = "Enable mirroring of RX packets",
+		.set = mt7530_set_port_mirror_rx,
+		.get = mt7530_get_port_mirror_rx,
+		.max = 1,
+	}, {
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_mirror_tx",
+		.description = "Enable mirroring of TX packets",
+		.set = mt7530_set_port_mirror_tx,
+		.get = mt7530_get_port_mirror_tx,
+		.max = 1,
+	},
+};
+
+static const struct switch_attr mt7621_vlan[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "vid",
+		.description = "VLAN ID (0-4094)",
+		.set = mt7530_set_vid,
+		.get = mt7621_get_vid,
+		.max = 4094,
 	},
 };
 
@@ -978,6 +1020,29 @@
 	},
 };
 
+static const struct switch_dev_ops mt7621_ops = {
+	.attr_global = {
+		.attr = mt7530_global,
+		.n_attr = ARRAY_SIZE(mt7530_global),
+	},
+	.attr_port = {
+		.attr = mt7621_port,
+		.n_attr = ARRAY_SIZE(mt7621_port),
+	},
+	.attr_vlan = {
+		.attr = mt7621_vlan,
+		.n_attr = ARRAY_SIZE(mt7621_vlan),
+	},
+	.get_vlan_ports = mt7530_get_vlan_ports,
+	.set_vlan_ports = mt7530_set_vlan_ports,
+	.get_port_pvid = mt7530_get_port_pvid,
+	.set_port_pvid = mt7530_set_port_pvid,
+	.get_port_link = mt7530_get_port_link,
+	.get_port_stats = mt7621_get_port_stats,
+	.apply_config = mt7530_apply_config,
+	.reset_switch = mt7530_reset_switch,
+};
+
 static const struct switch_dev_ops mt7530_ops = {
 	.attr_global = {
 		.attr = mt7530_global,
@@ -1021,6 +1086,9 @@
 	if (bus) {
 		swdev->alias = "mt7530";
 		swdev->name = "mt7530";
+	} else if (IS_ENABLED(CONFIG_SOC_MT7621)) {
+		swdev->alias = "mt7621";
+		swdev->name = "mt7621";
 	} else {
 		swdev->alias = "mt7620";
 		swdev->name = "mt7620";
@@ -1028,7 +1096,10 @@
 	swdev->cpu_port = MT7530_CPU_PORT;
 	swdev->ports = MT7530_NUM_PORTS;
 	swdev->vlans = MT7530_NUM_VLANS;
-	swdev->ops = &mt7530_ops;
+	if (IS_ENABLED(CONFIG_SOC_MT7621))
+		swdev->ops = &mt7621_ops;
+	else
+		swdev->ops = &mt7530_ops;
 
 	ret = register_switch(swdev, NULL);
 	if (ret) {
@@ -1043,7 +1114,7 @@
 	mt7530_apply_config(swdev);
 
 	/* magic vodoo */
-	if (bus && mt7530_r32(mt7530, REG_HWTRAP) !=  0x1117edf) {
+	if (!IS_ENABLED(CONFIG_SOC_MT7621) && bus && mt7530_r32(mt7530, REG_HWTRAP) !=  0x1117edf) {
 		dev_info(dev, "fixing up MHWTRAP register - bootloader probably played with it\n");
 		mt7530_w32(mt7530, REG_HWTRAP, 0x1117edf);
 	}

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/mt7530.h
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/mt7530.h
@@ -137,6 +137,50 @@
 /* Rx Event Packet Counter of Port n */
 #define MT7620_MIB_STATS_PORT_REPC2N	0x30
 
+#define MT7621_MIB_COUNTER_BASE	0x4000
+#define MT7621_MIB_COUNTER_PORT_OFFSET	0x100
+#define MT7621_STATS_TDPC	0x00
+#define MT7621_STATS_TCRC	0x04
+#define MT7621_STATS_TUPC	0x08
+#define MT7621_STATS_TMPC	0x0C
+#define MT7621_STATS_TBPC	0x10
+#define MT7621_STATS_TCEC	0x14
+#define MT7621_STATS_TSCEC	0x18
+#define MT7621_STATS_TMCEC	0x1C
+#define MT7621_STATS_TDEC	0x20
+#define MT7621_STATS_TLCEC	0x24
+#define MT7621_STATS_TXCEC	0x28
+#define MT7621_STATS_TPPC	0x2C
+#define MT7621_STATS_TL64PC	0x30
+#define MT7621_STATS_TL65PC	0x34
+#define MT7621_STATS_TL128PC	0x38
+#define MT7621_STATS_TL256PC	0x3C
+#define MT7621_STATS_TL512PC	0x40
+#define MT7621_STATS_TL1024PC	0x44
+#define MT7621_STATS_TOC	0x48
+#define MT7621_STATS_RDPC	0x60
+#define MT7621_STATS_RFPC	0x64
+#define MT7621_STATS_RUPC	0x68
+#define MT7621_STATS_RMPC	0x6C
+#define MT7621_STATS_RBPC	0x70
+#define MT7621_STATS_RAEPC	0x74
+#define MT7621_STATS_RCEPC	0x78
+#define MT7621_STATS_RUSPC	0x7C
+#define MT7621_STATS_RFEPC	0x80
+#define MT7621_STATS_ROSPC	0x84
+#define MT7621_STATS_RJEPC	0x88
+#define MT7621_STATS_RPPC	0x8C
+#define MT7621_STATS_RL64PC	0x90
+#define MT7621_STATS_RL65PC	0x94
+#define MT7621_STATS_RL128PC	0x98
+#define MT7621_STATS_RL256PC	0x9C
+#define MT7621_STATS_RL512PC	0xA0
+#define MT7621_STATS_RL1024PC	0xA4
+#define MT7621_STATS_ROC	0xA8
+#define MT7621_STATS_RDPC_CTRL	0xB0
+#define MT7621_STATS_RDPC_ING	0xB4
+#define MT7621_STATS_RDPC_ARL	0xB8
+
 int mt7530_probe(struct device *dev, void __iomem *base, struct mii_bus *bus, int vlan);
 
 #endif

--- /dev/null
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/mtk_debugfs.c
@@ -0,0 +1,115 @@
+/*   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; version 2 of the License
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   Copyright (C) 2014-2016 Sean Wang <sean.wang@mediatek.com>
+ *   Copyright (C) 2016-2017 John Crispin <blogic@openwrt.org>
+ */
+
+#include "mtk_offload.h"
+
+static const char *mtk_foe_entry_state_str[] = {
+	"INVALID",
+	"UNBIND",
+	"BIND",
+	"FIN"
+};
+
+static const char *mtk_foe_packet_type_str[] = {
+	"IPV4_HNAPT",
+	"IPV4_HNAT",
+	"IPV6_1T_ROUTE",
+	"IPV4_DSLITE",
+	"IPV6_3T_ROUTE",
+	"IPV6_5T_ROUTE",
+	"IPV6_6RD",
+};
+
+#define IPV4_HNAPT                      0
+#define IPV4_HNAT                       1
+#define IS_IPV4_HNAPT(x)	(((x)->bfib1.pkt_type == IPV4_HNAPT) ? 1: 0)
+static struct mtk_eth *_eth;
+#define es(entry)		(mtk_foe_entry_state_str[entry->bfib1.state])
+//#define ei(entry, end)		(MTK_PPE_TBL_SZ - (int)(end - entry))
+#define ei(entry, end)		(MTK_PPE_ENTRY_CNT - (int)(end - entry))
+#define pt(entry)		(mtk_foe_packet_type_str[entry->ipv4_hnapt.bfib1.pkt_type])
+
+static int mtk_ppe_debugfs_foe_show(struct seq_file *m, void *private)
+{
+	struct mtk_eth *eth = _eth;
+	struct mtk_foe_entry *entry, *end;
+	int i = 0;
+
+	entry = eth->foe_table;
+	end = eth->foe_table + MTK_PPE_ENTRY_CNT;
+
+	while (entry < end) {
+		if (IS_IPV4_HNAPT(entry)) {
+			__be32 saddr = htonl(entry->ipv4_hnapt.sip);
+			__be32 daddr = htonl(entry->ipv4_hnapt.dip);
+			__be32 nsaddr = htonl(entry->ipv4_hnapt.new_sip);
+			__be32 ndaddr = htonl(entry->ipv4_hnapt.new_dip);
+			unsigned char h_dest[ETH_ALEN];
+			unsigned char h_source[ETH_ALEN];
+
+			*((u32*) h_source) = swab32(entry->ipv4_hnapt.smac_hi);
+			*((u16*) &h_source[4]) = swab16(entry->ipv4_hnapt.smac_lo);
+			*((u32*) h_dest) = swab32(entry->ipv4_hnapt.dmac_hi);
+			*((u16*) &h_dest[4]) = swab16(entry->ipv4_hnapt.dmac_lo);
+			seq_printf(m,
+				   "(%x)0x%05x|state=%s|type=%s|"
+				   "%pI4:%d->%pI4:%d=>%pI4:%d->%pI4:%d|%pM=>%pM|"
+				   "etype=0x%04x|info1=0x%x|info2=0x%x|"
+				   "vlan1=%d|vlan2=%d\n",
+				   i,
+				   ei(entry, end), es(entry), pt(entry),
+				   &saddr, entry->ipv4_hnapt.sport,
+				   &daddr, entry->ipv4_hnapt.dport,
+				   &nsaddr, entry->ipv4_hnapt.new_sport,
+				   &ndaddr, entry->ipv4_hnapt.new_dport, h_source,
+				   h_dest, ntohs(entry->ipv4_hnapt.etype),
+				   entry->ipv4_hnapt.info_blk1,
+				   entry->ipv4_hnapt.info_blk2,
+				   entry->ipv4_hnapt.vlan1,
+				   entry->ipv4_hnapt.vlan2);
+		} else
+			seq_printf(m, "0x%05x state=%s\n",
+				   ei(entry, end), es(entry));
+		entry++;
+		i++;
+	}
+
+	return 0;
+}
+
+static int mtk_ppe_debugfs_foe_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, mtk_ppe_debugfs_foe_show, file->private_data);
+}
+
+static const struct file_operations mtk_ppe_debugfs_foe_fops = {
+	.open = mtk_ppe_debugfs_foe_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+int ra_ppe_debugfs_init(struct mtk_eth *eth)
+{
+	struct dentry *root;
+
+	_eth = eth;
+
+	root = debugfs_create_dir("mtk_ppe", NULL);
+	if (!root)
+		return -ENOMEM;
+
+	debugfs_create_file("all_entry", S_IRUGO, root, eth, &mtk_ppe_debugfs_foe_fops);
+
+	return 0;
+}

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/mtk_eth_soc.c
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/mtk_eth_soc.c
@@ -141,17 +141,6 @@
 	usleep_range(10, 20);
 }
 
-void fe_reset_fe(struct fe_priv *priv)
-{
-	if (!priv->rst_fe)
-		return;
-
-	reset_control_assert(priv->rst_fe);
-	usleep_range(60, 120);
-	reset_control_deassert(priv->rst_fe);
-	usleep_range(60, 120);
-}
-
 static inline void fe_int_disable(u32 mask)
 {
 	fe_reg_w32(fe_reg_r32(FE_REG_FE_INT_ENABLE) & ~mask,
@@ -575,7 +564,7 @@
 	barrier();
 	return (u32)(ring->tx_ring_size -
 			((ring->tx_next_idx - ring->tx_free_idx) &
-			 (ring->tx_ring_size - 1)));
+			 (ring->tx_ring_size - 1)) - 1);
 }
 
 struct fe_map_state {
@@ -726,11 +715,19 @@
 	/* TX SG offload */
 	nr_frags = skb_shinfo(skb)->nr_frags;
 	for (i = 0; i < nr_frags; i++) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+		struct skb_frag_struct *frag;
+#else
 		skb_frag_t *frag;
+#endif
 
 		frag = &skb_shinfo(skb)->frags[i];
 		if (fe_tx_dma_map_page(ring, &st, skb_frag_page(frag),
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+				       frag->page_offset, skb_frag_size(frag)))
+#else
 				       skb_frag_off(frag), skb_frag_size(frag)))
+#endif
 			goto err_dma;
 	}
 
@@ -765,7 +762,11 @@
 			netif_wake_queue(dev);
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 2, 0)
+	if (netif_xmit_stopped(netdev_get_tx_queue(dev, 0)) || !head->xmit_more)
+#else
 	if (netif_xmit_stopped(netdev_get_tx_queue(dev, 0)) || !netdev_xmit_more())
+#endif
 		fe_reg_w32(ring->tx_next_idx, FE_REG_TX_CTX_IDX0);
 
 	return 0;
@@ -824,14 +825,22 @@
 {
 	struct sk_buff *head = skb;
 	int i, nfrags = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	struct skb_frag_struct *frag;
+#else
 	skb_frag_t *frag;
+#endif
 
 next_frag:
 	nfrags++;
 	if (skb_is_gso(skb)) {
 		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 			frag = &skb_shinfo(skb)->frags[i];
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+			nfrags += DIV_ROUND_UP(frag->size, TX_DMA_BUF_LEN);
+#else
 			nfrags += DIV_ROUND_UP(skb_frag_size(frag), TX_DMA_BUF_LEN);
+#endif
 		}
 	} else {
 		nfrags += skb_shinfo(skb)->nr_frags;
@@ -951,11 +960,18 @@
 			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
 					       RX_DMA_VID(trxd.rxd3));
 
-		stats->rx_packets++;
-		stats->rx_bytes += pktlen;
-
-		napi_gro_receive(napi, skb);
+#ifdef CONFIG_NET_RALINK_OFFLOAD
+		if (ra_offload_check_rx(priv, skb, trxd.rxd4) == 0) {
+#endif
+			stats->rx_packets++;
+			stats->rx_bytes += pktlen;
 
+			napi_gro_receive(napi, skb);
+#ifdef CONFIG_NET_RALINK_OFFLOAD
+		} else {
+			dev_kfree_skb(skb);
+		}
+#endif
 		ring->rx_data[idx] = new_data;
 		rxd->rxd1 = (unsigned int)dma_addr;
 
@@ -1296,6 +1312,9 @@
 	napi_enable(&priv->rx_napi);
 	fe_int_enable(priv->soc->tx_int | priv->soc->rx_int);
 	netif_start_queue(dev);
+#ifdef CONFIG_NET_RALINK_OFFLOAD
+	ra_ppe_probe(priv);
+#endif
 
 	return 0;
 }
@@ -1332,6 +1351,10 @@
 
 	fe_free_dma(priv);
 
+#ifdef CONFIG_NET_RALINK_OFFLOAD
+	ra_ppe_remove(priv);
+#endif
+
 	return 0;
 }
 
@@ -1368,27 +1391,22 @@
 {
 	struct fe_priv *priv = netdev_priv(dev);
 	struct device_node *port;
+	const char *mac_addr;
 	int err;
 
-	if (priv->soc->reset_fe)
-		priv->soc->reset_fe(priv);
-	else
-		fe_reset_fe(priv);
-
-	if (priv->soc->switch_init) {
-		err = priv->soc->switch_init(priv);
-		if (err) {
-			if (err == -EPROBE_DEFER)
-				return err;
+	priv->soc->reset_fe();
 
+	if (priv->soc->switch_init)
+		if (priv->soc->switch_init(priv)) {
 			netdev_err(dev, "failed to initialize switch core\n");
 			return -ENODEV;
 		}
-	}
 
 	fe_reset_phy(priv);
 
-	of_get_mac_address(priv->dev->of_node, dev->dev_addr);
+	mac_addr = of_get_mac_address(priv->dev->of_node);
+	if (!IS_ERR_OR_NULL(mac_addr))
+		ether_addr_copy(dev->dev_addr, mac_addr);
 
 	/* If the mac address is invalid, use random mac address  */
 	if (!is_valid_ether_addr(dev->dev_addr)) {
@@ -1497,6 +1515,23 @@
 	return fe_open(dev);
 }
 
+#ifdef CONFIG_NET_RALINK_OFFLOAD
+static int
+fe_flow_offload(enum flow_offload_type type, struct flow_offload *flow,
+		struct flow_offload_hw_path *src,
+		struct flow_offload_hw_path *dest)
+{
+	struct fe_priv *priv;
+
+	if (src->dev != dest->dev)
+		return -EINVAL;
+
+	priv = netdev_priv(src->dev);
+
+	return mtk_flow_offload(priv, type, flow, src, dest);
+}
+#endif
+
 static const struct net_device_ops fe_netdev_ops = {
 	.ndo_init		= fe_init,
 	.ndo_uninit		= fe_uninit,
@@ -1514,6 +1549,9 @@
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller	= fe_poll_controller,
 #endif
+#ifdef CONFIG_NET_RALINK_OFFLOAD
+	.ndo_flow_offload	= fe_flow_offload,
+#endif
 };
 
 static void fe_reset_pending(struct fe_priv *priv)
@@ -1595,12 +1633,6 @@
 		goto err_free_dev;
 	}
 
-	priv = netdev_priv(netdev);
-	spin_lock_init(&priv->page_lock);
-	priv->rst_fe = devm_reset_control_get(&pdev->dev, "fe");
-	if (IS_ERR(priv->rst_fe))
-		priv->rst_fe = NULL;
-
 	if (soc->init_data)
 		soc->init_data(soc, netdev);
 	netdev->vlan_features = netdev->hw_features &
@@ -1615,6 +1647,8 @@
 	if (fe_reg_table[FE_REG_FE_DMA_VID_BASE])
 		netdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
 
+	priv = netdev_priv(netdev);
+	spin_lock_init(&priv->page_lock);
 	if (fe_reg_table[FE_REG_FE_COUNTER_BASE]) {
 		priv->hw_stats = kzalloc(sizeof(*priv->hw_stats), GFP_KERNEL);
 		if (!priv->hw_stats) {
@@ -1702,7 +1736,7 @@
 	.probe = fe_probe,
 	.remove = fe_remove,
 	.driver = {
-		.name = "mtk_soc_eth",
+		.name = "ralink_soc_eth",
 		.owner = THIS_MODULE,
 		.of_match_table = of_fe_match,
 	},

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/mtk_eth_soc.h
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/mtk_eth_soc.h
@@ -49,7 +49,7 @@
 	FE_FLAG_MAX
 };
 
-#define MTK_FE_DRV_VERSION		"0.2"
+#define MTK_FE_DRV_VERSION		"0.1.2"
 
 /* power of 2 to let NEXT_TX_DESP_IDX work */
 #define NUM_DMA_DESC		BIT(10)
@@ -157,10 +157,6 @@
 #define MT7620A_FE_GDMA1_MAC_ADRL	(MT7620A_GDMA_OFFSET + 0x0C)
 #define MT7620A_FE_GDMA1_MAC_ADRH	(MT7620A_GDMA_OFFSET + 0x10)
 
-#define MT7620A_RESET_FE	BIT(21)
-#define MT7620A_RESET_ESW	BIT(23)
-#define MT7620A_RESET_EPHY	BIT(24)
-
 #define RT5350_TX_BASE_PTR0	(RT5350_PDMA_OFFSET + 0x00)
 #define RT5350_TX_MAX_CNT0	(RT5350_PDMA_OFFSET + 0x04)
 #define RT5350_TX_CTX_IDX0	(RT5350_PDMA_OFFSET + 0x08)
@@ -382,7 +378,7 @@
 	const u16 *reg_table;
 
 	void (*init_data)(struct fe_soc_data *data, struct net_device *netdev);
-	void (*reset_fe)(struct fe_priv *priv);
+	void (*reset_fe)(void);
 	void (*set_mac)(struct fe_priv *priv, unsigned char *mac);
 	int (*fwd_config)(struct fe_priv *priv);
 	void (*tx_dma)(struct fe_tx_dma *txd);
@@ -498,7 +494,6 @@
 	DECLARE_BITMAP(pending_flags, FE_FLAG_MAX);
 
 	struct reset_control		*rst_ppe;
-	struct reset_control		*rst_fe;
 	struct mtk_foe_entry		*foe_table;
 	dma_addr_t			foe_table_phys;
 	struct flow_offload __rcu	**foe_flow_table;
@@ -518,12 +513,20 @@
 u32 fe_reg_r32(enum fe_reg reg);
 
 void fe_reset(u32 reset_bits);
-void fe_reset_fe(struct fe_priv *priv);
 
 static inline void *priv_netdev(struct fe_priv *priv)
 {
 	return (char *)priv - ALIGN(sizeof(struct net_device), NETDEV_ALIGN);
 }
 
+int ra_ppe_probe(struct fe_priv *eth);
+void ra_ppe_remove(struct fe_priv *eth);
+int mtk_flow_offload(struct fe_priv *eth,
+		     enum flow_offload_type type,
+		     struct flow_offload *flow,
+		     struct flow_offload_hw_path *src,
+		     struct flow_offload_hw_path *dest);
+int ra_offload_check_rx(struct fe_priv *eth, struct sk_buff *skb, u32 rxd4);
+
 
 #endif /* FE_ETH_H */

--- /dev/null
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/mtk_offload.c
@@ -0,0 +1,540 @@
+/*   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; version 2 of the License
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   Copyright (C) 2018 John Crispin <john@phrozen.org>
+ */
+
+#include "mtk_offload.h"
+
+#define INVALID	0
+#define UNBIND	1
+#define BIND	2
+#define FIN	3
+
+#define IPV4_HNAPT			0
+#define IPV4_HNAT			1
+
+static u32
+mtk_flow_hash_v4(struct flow_offload_tuple *tuple)
+{
+	u32 ports = ntohs(tuple->src_port)  << 16 | ntohs(tuple->dst_port);
+	u32 src = ntohl(tuple->dst_v4.s_addr);
+	u32 dst = ntohl(tuple->src_v4.s_addr);
+	u32 hash = (ports & src) | ((~ports) & dst);
+	u32 hash_23_0 = hash & 0xffffff;
+	u32 hash_31_24 = hash & 0xff000000;
+
+	hash = ports ^ src ^ dst ^ ((hash_23_0 << 8) | (hash_31_24 >> 24));
+	hash = ((hash & 0xffff0000) >> 16 ) ^ (hash & 0xfffff);
+	hash &= 0x7ff;
+	hash *= 2;;
+
+	return hash;
+}
+
+static int
+mtk_foe_prepare_v4(struct mtk_foe_entry *entry,
+		   struct flow_offload_tuple *tuple,
+		   struct flow_offload_tuple *dest_tuple,
+		   struct flow_offload_hw_path *src,
+		   struct flow_offload_hw_path *dest)
+{
+	int is_mcast = !!is_multicast_ether_addr(dest->eth_dest);
+
+	if (tuple->l4proto == IPPROTO_UDP)
+		entry->ipv4_hnapt.bfib1.udp = 1;
+
+	entry->ipv4_hnapt.etype = htons(ETH_P_IP);
+	entry->ipv4_hnapt.bfib1.pkt_type = IPV4_HNAPT;
+	entry->ipv4_hnapt.iblk2.fqos = 0;
+	entry->ipv4_hnapt.bfib1.ttl = 1;
+	entry->ipv4_hnapt.bfib1.cah = 1;
+	entry->ipv4_hnapt.bfib1.ka = 1;
+	entry->ipv4_hnapt.iblk2.mcast = is_mcast;
+	entry->ipv4_hnapt.iblk2.dscp = 0;
+	entry->ipv4_hnapt.iblk2.port_mg = 0x3f;
+	entry->ipv4_hnapt.iblk2.port_ag = 0x1f;
+#ifdef CONFIG_NET_RALINK_HW_QOS
+	entry->ipv4_hnapt.iblk2.qid = 1;
+	entry->ipv4_hnapt.iblk2.fqos = 1;
+#endif
+#ifdef CONFIG_RALINK
+	entry->ipv4_hnapt.iblk2.dp = 1;
+	if ((dest->flags & FLOW_OFFLOAD_PATH_VLAN) && (dest->vlan_id > 1))
+		entry->ipv4_hnapt.iblk2.qid += 8;
+#else
+	entry->ipv4_hnapt.iblk2.dp = (dest->dev->name[3] - '0') + 1;
+#endif
+
+	entry->ipv4_hnapt.sip = ntohl(tuple->src_v4.s_addr);
+	entry->ipv4_hnapt.dip = ntohl(tuple->dst_v4.s_addr);
+	entry->ipv4_hnapt.sport = ntohs(tuple->src_port);
+	entry->ipv4_hnapt.dport = ntohs(tuple->dst_port);
+
+	entry->ipv4_hnapt.new_sip = ntohl(dest_tuple->dst_v4.s_addr);
+	entry->ipv4_hnapt.new_dip = ntohl(dest_tuple->src_v4.s_addr);
+	entry->ipv4_hnapt.new_sport = ntohs(dest_tuple->dst_port);
+	entry->ipv4_hnapt.new_dport = ntohs(dest_tuple->src_port);
+
+	entry->bfib1.state = BIND;
+
+	if (dest->flags & FLOW_OFFLOAD_PATH_PPPOE) {
+		entry->bfib1.psn = 1;
+		entry->ipv4_hnapt.etype = htons(ETH_P_PPP_SES);
+		entry->ipv4_hnapt.pppoe_id = dest->pppoe_sid;
+	}
+
+	if (dest->flags & FLOW_OFFLOAD_PATH_VLAN) {
+		entry->ipv4_hnapt.vlan1 = dest->vlan_id;
+		entry->bfib1.vlan_layer = 1;
+
+		switch (dest->vlan_proto) {
+		case htons(ETH_P_8021Q):
+			entry->ipv4_hnapt.bfib1.vpm = 1;
+			break;
+		case htons(ETH_P_8021AD):
+			entry->ipv4_hnapt.bfib1.vpm = 2;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static void
+mtk_foe_set_mac(struct mtk_foe_entry *entry, u8 *smac, u8 *dmac)
+{
+	entry->ipv4_hnapt.dmac_hi = swab32(*((u32*) dmac));
+	entry->ipv4_hnapt.dmac_lo = swab16(*((u16*) &dmac[4]));
+	entry->ipv4_hnapt.smac_hi = swab32(*((u32*) smac));
+	entry->ipv4_hnapt.smac_lo = swab16(*((u16*) &smac[4]));
+}
+
+static int
+mtk_check_entry_available(struct mtk_eth *eth, u32 hash)
+{
+	struct mtk_foe_entry entry = ((struct mtk_foe_entry *)eth->foe_table)[hash];
+
+	return (entry.bfib1.state == BIND)? 0:1;
+}
+
+static void
+mtk_foe_write(struct mtk_eth *eth, u32 hash,
+	      struct mtk_foe_entry *entry)
+{
+	struct mtk_foe_entry *table = (struct mtk_foe_entry *)eth->foe_table;
+
+	memcpy(&table[hash], entry, sizeof(*entry));
+}
+
+int mtk_flow_offload(struct mtk_eth *eth,
+		     enum flow_offload_type type,
+		     struct flow_offload *flow,
+		     struct flow_offload_hw_path *src,
+		     struct flow_offload_hw_path *dest)
+{
+	struct flow_offload_tuple *otuple = &flow->tuplehash[FLOW_OFFLOAD_DIR_ORIGINAL].tuple;
+	struct flow_offload_tuple *rtuple = &flow->tuplehash[FLOW_OFFLOAD_DIR_REPLY].tuple;
+	u32 time_stamp = mtk_r32(eth, 0x0010) & (0x7fff);
+	u32 ohash, rhash;
+	struct mtk_foe_entry orig = {
+		.bfib1.time_stamp = time_stamp,
+		.bfib1.psn = 0,
+	};
+	struct mtk_foe_entry reply = {
+		.bfib1.time_stamp = time_stamp,
+		.bfib1.psn = 0,
+	};
+
+	if (otuple->l4proto != IPPROTO_TCP && otuple->l4proto != IPPROTO_UDP)
+		return -EINVAL;
+	
+	if (type == FLOW_OFFLOAD_DEL) {
+		flow = NULL;
+		synchronize_rcu();
+		return 0;
+	}
+
+	switch (otuple->l3proto) {
+	case AF_INET:
+		if (mtk_foe_prepare_v4(&orig, otuple, rtuple, src, dest) ||
+		    mtk_foe_prepare_v4(&reply, rtuple, otuple, dest, src))
+			return -EINVAL;
+
+		ohash = mtk_flow_hash_v4(otuple);
+		rhash = mtk_flow_hash_v4(rtuple);
+		break;
+
+	case AF_INET6:
+		return -EINVAL;
+
+	default:
+		return -EINVAL;
+	}
+
+	/* Two-way hash: when hash collision occurs, the hash value will be shifted to the next position. */
+	if (!mtk_check_entry_available(eth, ohash)){       
+		if (!mtk_check_entry_available(eth, ohash + 1))
+			return -EINVAL;
+                ohash += 1;
+        }
+        if (!mtk_check_entry_available(eth, rhash)){
+		if (!mtk_check_entry_available(eth, rhash + 1))
+                        return -EINVAL;
+                rhash += 1;
+	}
+
+	mtk_foe_set_mac(&orig, dest->eth_src, dest->eth_dest);
+	mtk_foe_set_mac(&reply, src->eth_src, src->eth_dest);
+	mtk_foe_write(eth, ohash, &orig);
+	mtk_foe_write(eth, rhash, &reply);
+	rcu_assign_pointer(eth->foe_flow_table[ohash], flow);
+	rcu_assign_pointer(eth->foe_flow_table[rhash], flow);
+
+	return 0;
+}
+
+#ifdef CONFIG_NET_RALINK_HW_QOS
+
+#define QDMA_TX_SCH_TX	  0x1a14
+
+static void mtk_ppe_scheduler(struct mtk_eth *eth, int id, u32 rate)
+{
+	int exp = 0, shift = 0;
+	u32 reg = mtk_r32(eth, QDMA_TX_SCH_TX);
+	u32 val = 0;
+
+	if (rate)
+		val = BIT(11);
+
+	while (rate > 127) {
+		rate /= 10;
+		exp++;
+	}
+
+	val |= (rate & 0x7f) << 4;
+	val |= exp & 0xf;
+	if (id)
+		shift = 16;
+	reg &= ~(0xffff << shift);
+	reg |= val << shift;
+	mtk_w32(eth, val, QDMA_TX_SCH_TX);
+}
+
+#define QTX_CFG(x)	(0x1800 + (x * 0x10))
+#define QTX_SCH(x)	(0x1804 + (x * 0x10))
+
+static void mtk_ppe_queue(struct mtk_eth *eth, int id, int sched, int weight, int resv, u32 min_rate, u32 max_rate)
+{
+	int max_exp = 0, min_exp = 0;
+	u32 reg;
+
+	if (id >= 16)
+		return;
+
+	reg = mtk_r32(eth, QTX_SCH(id));
+	reg &= 0x70000000;
+
+	if (sched)
+		reg |= BIT(31);
+
+	if (min_rate)
+		reg |= BIT(27);
+
+	if (max_rate)
+		reg |= BIT(11);
+
+	while (max_rate > 127) {
+		max_rate /= 10;
+		max_exp++;
+	}
+
+	while (min_rate > 127) {
+		min_rate /= 10;
+		min_exp++;
+	}
+
+	reg |= (min_rate & 0x7f) << 20;
+	reg |= (min_exp & 0xf) << 16;
+	reg |= (weight & 0xf) << 12;
+	reg |= (max_rate & 0x7f) << 4;
+	reg |= max_exp & 0xf;
+	mtk_w32(eth, reg, QTX_SCH(id));
+
+	resv &= 0xff;
+	reg = mtk_r32(eth, QTX_CFG(id));
+	reg &= 0xffff0000;
+	reg |= (resv << 8) | resv;
+	mtk_w32(eth, reg, QTX_CFG(id));
+}
+#endif
+
+static int mtk_init_foe_table(struct mtk_eth *eth)
+{
+	if (eth->foe_table)
+		return 0;
+
+	eth->foe_flow_table = devm_kcalloc(eth->dev, MTK_PPE_ENTRY_CNT,
+					   sizeof(*eth->foe_flow_table),
+					   GFP_KERNEL);
+	if (!eth->foe_flow_table)
+		return -EINVAL;
+
+	/* map the FOE table */
+	eth->foe_table = dmam_alloc_coherent(eth->dev, MTK_PPE_TBL_SZ,
+					     &eth->foe_table_phys, GFP_KERNEL);
+	if (!eth->foe_table) {
+		dev_err(eth->dev, "failed to allocate foe table\n");
+		kfree(eth->foe_flow_table);
+		return -ENOMEM;
+	}
+
+
+	return 0;
+}
+
+static int ra_ppe_start(struct mtk_eth *eth)
+{
+	int ret;
+
+	ret = mtk_init_foe_table(eth);
+	if (ret)
+		return ret;
+
+	/* tell the PPE about the tables base address */
+	mtk_w32(eth, eth->foe_table_phys, MTK_REG_PPE_TB_BASE);
+
+	/* flush the table */
+	memset(eth->foe_table, 0, MTK_PPE_TBL_SZ);
+
+	/* setup hashing */
+	mtk_m32(eth,
+		MTK_PPE_TB_CFG_HASH_MODE_MASK | MTK_PPE_TB_CFG_TBL_SZ_MASK,
+		MTK_PPE_TB_CFG_HASH_MODE1 | MTK_PPE_TB_CFG_TBL_SZ_4K,
+		MTK_REG_PPE_TB_CFG);
+
+	/* set the default hashing seed */
+	mtk_w32(eth, MTK_PPE_HASH_SEED, MTK_REG_PPE_HASH_SEED);
+
+	/* each foe entry is 64bytes and is setup by cpu forwarding*/
+	mtk_m32(eth, MTK_PPE_CAH_CTRL_X_MODE | MTK_PPE_TB_CFG_ENTRY_SZ_MASK |
+		MTK_PPE_TB_CFG_SMA_MASK,
+		MTK_PPE_TB_CFG_ENTRY_SZ_64B |  MTK_PPE_TB_CFG_SMA_FWD_CPU,
+		MTK_REG_PPE_TB_CFG);
+
+	/* set ip proto */
+	mtk_w32(eth, 0xFFFFFFFF, MTK_REG_PPE_IP_PROT_CHK);
+
+	/* setup caching */
+	mtk_m32(eth, 0, MTK_PPE_CAH_CTRL_X_MODE, MTK_REG_PPE_CAH_CTRL);
+	mtk_m32(eth, MTK_PPE_CAH_CTRL_X_MODE, MTK_PPE_CAH_CTRL_EN,
+		MTK_REG_PPE_CAH_CTRL);
+
+	/* enable FOE */
+	mtk_m32(eth, 0, MTK_PPE_FLOW_CFG_IPV4_NAT_FRAG_EN |
+		MTK_PPE_FLOW_CFG_IPV4_NAPT_EN | MTK_PPE_FLOW_CFG_IPV4_NAT_EN |
+		MTK_PPE_FLOW_CFG_IPV4_GREK_EN,
+		MTK_REG_PPE_FLOW_CFG);
+
+	/* setup flow entry un/bind aging */
+	mtk_m32(eth, 0,
+		MTK_PPE_TB_CFG_UNBD_AGE | MTK_PPE_TB_CFG_NTU_AGE |
+		MTK_PPE_TB_CFG_FIN_AGE | MTK_PPE_TB_CFG_UDP_AGE |
+		MTK_PPE_TB_CFG_TCP_AGE,
+		MTK_REG_PPE_TB_CFG);
+
+	mtk_m32(eth, MTK_PPE_UNB_AGE_MNP_MASK | MTK_PPE_UNB_AGE_DLTA_MASK,
+		MTK_PPE_UNB_AGE_MNP | MTK_PPE_UNB_AGE_DLTA,
+		MTK_REG_PPE_UNB_AGE);
+	mtk_m32(eth, MTK_PPE_BND_AGE0_NTU_DLTA_MASK |
+		MTK_PPE_BND_AGE0_UDP_DLTA_MASK,
+		MTK_PPE_BND_AGE0_NTU_DLTA | MTK_PPE_BND_AGE0_UDP_DLTA,
+		MTK_REG_PPE_BND_AGE0);
+	mtk_m32(eth, MTK_PPE_BND_AGE1_FIN_DLTA_MASK |
+		MTK_PPE_BND_AGE1_TCP_DLTA_MASK,
+		MTK_PPE_BND_AGE1_FIN_DLTA | MTK_PPE_BND_AGE1_TCP_DLTA,
+		MTK_REG_PPE_BND_AGE1);
+
+	/* setup flow entry keep alive */
+	mtk_m32(eth, MTK_PPE_TB_CFG_KA_MASK, MTK_PPE_TB_CFG_KA,
+		MTK_REG_PPE_TB_CFG);
+	mtk_w32(eth, MTK_PPE_KA_UDP | MTK_PPE_KA_TCP | MTK_PPE_KA_T, MTK_REG_PPE_KA);
+
+	/* setup flow entry rate limit */
+	mtk_w32(eth, (0x3fff << 16) | 0x3fff, MTK_REG_PPE_BIND_LMT_0);
+	mtk_w32(eth, MTK_PPE_NTU_KA | 0x3fff, MTK_REG_PPE_BIND_LMT_1);
+	mtk_m32(eth, MTK_PPE_BNDR_RATE_MASK, 1, MTK_REG_PPE_BNDR);
+
+	/* enable the PPE */
+	mtk_m32(eth, 0, MTK_PPE_GLO_CFG_EN, MTK_REG_PPE_GLO_CFG);
+
+#ifdef CONFIG_RALINK
+	/* set the default forwarding port to QDMA */
+	mtk_w32(eth, 0x0, MTK_REG_PPE_DFT_CPORT);
+#else
+	/* set the default forwarding port to QDMA */
+	mtk_w32(eth, 0x55555555, MTK_REG_PPE_DFT_CPORT);
+#endif
+
+	/* allow packets with TTL=0 */
+	mtk_m32(eth, MTK_PPE_GLO_CFG_TTL0_DROP, 0, MTK_REG_PPE_GLO_CFG);
+
+	/* send all traffic from gmac to the ppe */
+	mtk_m32(eth, 0xffff, 0x4444, MTK_GDMA_FWD_CFG(0));
+	mtk_m32(eth, 0xffff, 0x4444, MTK_GDMA_FWD_CFG(1));
+
+	dev_info(eth->dev, "PPE started\n");
+
+#ifdef CONFIG_NET_RALINK_HW_QOS
+	mtk_ppe_scheduler(eth, 0, 500000);
+	mtk_ppe_scheduler(eth, 1, 500000);
+	mtk_ppe_queue(eth, 0, 0, 7, 32, 250000, 0);
+	mtk_ppe_queue(eth, 1, 0, 7, 32, 250000, 0);
+	mtk_ppe_queue(eth, 8, 1, 7, 32, 250000, 0);
+	mtk_ppe_queue(eth, 9, 1, 7, 32, 250000, 0);
+#endif
+
+	return 0;
+}
+
+static int mtk_ppe_busy_wait(struct mtk_eth *eth)
+{
+	unsigned long t_start = jiffies;
+	u32 r = 0;
+
+	while (1) {
+		r = mtk_r32(eth, MTK_REG_PPE_GLO_CFG);
+		if (!(r & MTK_PPE_GLO_CFG_BUSY))
+			return 0;
+		if (time_after(jiffies, t_start + HZ))
+			break;
+		usleep_range(10, 20);
+	}
+
+	dev_err(eth->dev, "ppe: table busy timeout - resetting\n");
+	reset_control_reset(eth->rst_ppe);
+
+	return -ETIMEDOUT;
+}
+
+static int ra_ppe_stop(struct mtk_eth *eth)
+{
+	u32 r1 = 0, r2 = 0;
+	int i;
+
+	/* discard all traffic while we disable the PPE */
+	mtk_m32(eth, 0xffff, 0x7777, MTK_GDMA_FWD_CFG(0));
+	mtk_m32(eth, 0xffff, 0x7777, MTK_GDMA_FWD_CFG(1));
+
+	if (mtk_ppe_busy_wait(eth))
+		return -ETIMEDOUT;
+
+	/* invalidate all flow table entries */
+	for (i = 0; i < MTK_PPE_ENTRY_CNT; i++)
+		eth->foe_table[i].bfib1.state = FOE_STATE_INVALID;
+
+	/* disable caching */
+	mtk_m32(eth, 0, MTK_PPE_CAH_CTRL_X_MODE, MTK_REG_PPE_CAH_CTRL);
+	mtk_m32(eth, MTK_PPE_CAH_CTRL_X_MODE | MTK_PPE_CAH_CTRL_EN, 0,
+		MTK_REG_PPE_CAH_CTRL);
+
+	/* flush cache has to be ahead of hnat diable --*/
+	mtk_m32(eth, MTK_PPE_GLO_CFG_EN, 0, MTK_REG_PPE_GLO_CFG);
+
+	/* disable FOE */
+	mtk_m32(eth,
+		MTK_PPE_FLOW_CFG_IPV4_NAT_FRAG_EN |
+		MTK_PPE_FLOW_CFG_IPV4_NAPT_EN | MTK_PPE_FLOW_CFG_IPV4_NAT_EN |
+		MTK_PPE_FLOW_CFG_FUC_FOE | MTK_PPE_FLOW_CFG_FMC_FOE,
+		0, MTK_REG_PPE_FLOW_CFG);
+
+	/* disable FOE aging */
+	mtk_m32(eth, 0,
+		MTK_PPE_TB_CFG_FIN_AGE | MTK_PPE_TB_CFG_UDP_AGE |
+		MTK_PPE_TB_CFG_TCP_AGE | MTK_PPE_TB_CFG_UNBD_AGE |
+		MTK_PPE_TB_CFG_NTU_AGE, MTK_REG_PPE_TB_CFG);
+
+	r1 = mtk_r32(eth, 0x100);
+	r2 = mtk_r32(eth, 0x10c);
+
+	dev_info(eth->dev, "0x100 = 0x%x, 0x10c = 0x%x\n", r1, r2);
+
+	if (((r1 & 0xff00) >> 0x8) >= (r1 & 0xff) ||
+	    ((r1 & 0xff00) >> 0x8) >= (r2 & 0xff)) {
+		dev_info(eth->dev, "reset pse\n");
+		mtk_w32(eth, 0x1, 0x4);
+	}
+
+	/* set the foe entry base address to 0 */
+	mtk_w32(eth, 0, MTK_REG_PPE_TB_BASE);
+
+	if (mtk_ppe_busy_wait(eth))
+		return -ETIMEDOUT;
+
+	/* send all traffic back to the DMA engine */
+#ifdef CONFIG_RALINK
+	mtk_m32(eth, 0xffff, 0x0, MTK_GDMA_FWD_CFG(0));
+	mtk_m32(eth, 0xffff, 0x0, MTK_GDMA_FWD_CFG(1));
+#else
+	mtk_m32(eth, 0xffff, 0x5555, MTK_GDMA_FWD_CFG(0));
+	mtk_m32(eth, 0xffff, 0x5555, MTK_GDMA_FWD_CFG(1));
+#endif
+	return 0;
+}
+
+static void mtk_offload_keepalive(struct fe_priv *eth, unsigned int hash)
+{
+	struct flow_offload *flow;
+
+	rcu_read_lock();
+	flow = rcu_dereference(eth->foe_flow_table[hash]);
+	if (flow)
+		flow->timeout = jiffies + 30 * HZ;
+	rcu_read_unlock();
+}
+
+int ra_offload_check_rx(struct fe_priv *eth, struct sk_buff *skb, u32 rxd4)
+{
+	unsigned int hash;
+
+	switch (FIELD_GET(MTK_RXD4_CPU_REASON, rxd4)) {
+	case MTK_CPU_REASON_KEEPALIVE_UC_OLD_HDR:
+	case MTK_CPU_REASON_KEEPALIVE_MC_NEW_HDR:
+	case MTK_CPU_REASON_KEEPALIVE_DUP_OLD_HDR:
+		hash = FIELD_GET(MTK_RXD4_FOE_ENTRY, rxd4);
+		mtk_offload_keepalive(eth, hash);
+		return -1;
+	case MTK_CPU_REASON_PACKET_SAMPLING:
+		return -1;
+	default:
+		return 0;
+	}
+}
+
+int ra_ppe_probe(struct mtk_eth *eth)
+{
+	int err;
+
+	err = ra_ppe_start(eth);
+	if (err)
+		return err;
+
+	err = ra_ppe_debugfs_init(eth);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+void ra_ppe_remove(struct mtk_eth *eth)
+{
+	ra_ppe_stop(eth);
+}

--- /dev/null
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/mtk_offload.h
@@ -0,0 +1,260 @@
+/*   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; version 2 of the License
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   Copyright (C) 2014-2016 Sean Wang <sean.wang@mediatek.com>
+ *   Copyright (C) 2016-2017 John Crispin <blogic@openwrt.org>
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/if.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/netfilter.h>
+#include <linux/netdevice.h>
+#include <net/netfilter/nf_flow_table.h>
+#include <linux/debugfs.h>
+#include <linux/etherdevice.h>
+#include <linux/bitfield.h>
+
+#include "mtk_eth_soc.h"
+
+#ifdef CONFIG_RALINK
+/* ramips compat */
+#define mtk_eth					fe_priv
+#define MTK_GDMA_FWD_CFG(x)			(0x500 + (x * 0x1000))
+#define mtk_m32					fe_m32
+
+static inline u32
+mtk_r32(struct mtk_eth *eth, u32 reg)
+{
+	return fe_r32(reg);
+}
+
+static inline void
+mtk_w32(struct mtk_eth *eth, u32 val, u32 reg)
+{
+	fe_w32(val, reg);
+}
+#endif
+
+#define MTK_REG_PPE_GLO_CFG			0xe00
+#define   MTK_PPE_GLO_CFG_BUSY			BIT(31)
+#define   MTK_PPE_GLO_CFG_TTL0_DROP		BIT(4)
+#define   MTK_PPE_GLO_CFG_EN			BIT(0)
+
+#define MTK_REG_PPE_FLOW_CFG			0xe04
+#define   MTK_PPE_FLOW_CFG_IPV4_GREK_EN		BIT(19)
+#define   MTK_PPE_FLOW_CFG_IPV4_NAT_FRAG_EN	BIT(17)
+#define   MTK_PPE_FLOW_CFG_IPV4_NAPT_EN		BIT(13)
+#define   MTK_PPE_FLOW_CFG_IPV4_NAT_EN		BIT(12)
+#define   MTK_PPE_FLOW_CFG_FUC_FOE		BIT(2)
+#define   MTK_PPE_FLOW_CFG_FMC_FOE		BIT(1)
+
+#define MTK_REG_PPE_IP_PROT_CHK			0xe08
+
+#define MTK_REG_PPE_TB_BASE			0xe20
+
+#define MTK_REG_PPE_BNDR			0xe28
+#define   MTK_PPE_BNDR_RATE_MASK		0xffff
+
+#define MTK_REG_PPE_BIND_LMT_0			0xe2C
+
+#define MTK_REG_PPE_BIND_LMT_1			0xe30
+#define   MTK_PPE_NTU_KA			BIT(16)
+
+#define MTK_REG_PPE_KA				0xe34
+#define   MTK_PPE_KA_T				BIT(0)
+#define   MTK_PPE_KA_TCP			BIT(16)
+#define   MTK_PPE_KA_UDP			BIT(24)
+
+#define MTK_REG_PPE_UNB_AGE			0xe38
+#define   MTK_PPE_UNB_AGE_MNP_MASK		(0xffff << 16)
+#define   MTK_PPE_UNB_AGE_MNP			(1000 << 16)
+#define   MTK_PPE_UNB_AGE_DLTA_MASK		0xff
+#define   MTK_PPE_UNB_AGE_DLTA			3
+
+#define MTK_REG_PPE_BND_AGE0			0xe3c
+#define   MTK_PPE_BND_AGE0_NTU_DLTA_MASK	(0xffff << 16)
+#define   MTK_PPE_BND_AGE0_NTU_DLTA		(5 << 16)
+#define   MTK_PPE_BND_AGE0_UDP_DLTA_MASK	0xffff
+#define   MTK_PPE_BND_AGE0_UDP_DLTA		5
+
+#define MTK_REG_PPE_BND_AGE1			0xe40
+#define   MTK_PPE_BND_AGE1_FIN_DLTA_MASK	(0xffff << 16)
+#define   MTK_PPE_BND_AGE1_FIN_DLTA		(5 << 16)
+#define   MTK_PPE_BND_AGE1_TCP_DLTA_MASK	0xffff
+#define   MTK_PPE_BND_AGE1_TCP_DLTA		5
+
+#define MTK_REG_PPE_DFT_CPORT			0xe48
+
+#define MTK_REG_PPE_TB_CFG			0xe1c
+#define   MTK_PPE_TB_CFG_X_MODE_MASK		(3 << 18)
+#define   MTK_PPE_TB_CFG_HASH_MODE1		BIT(14)
+#define   MTK_PPE_TB_CFG_HASH_MODE_MASK		(0x3 << 14)
+#define   MTK_PPE_TB_CFG_KA			(3 << 12)
+#define   MTK_PPE_TB_CFG_KA_MASK		(0x3 << 12)
+#define   MTK_PPE_TB_CFG_FIN_AGE		BIT(11)
+#define   MTK_PPE_TB_CFG_UDP_AGE		BIT(10)
+#define   MTK_PPE_TB_CFG_TCP_AGE		BIT(9)
+#define   MTK_PPE_TB_CFG_UNBD_AGE		BIT(8)
+#define   MTK_PPE_TB_CFG_NTU_AGE		BIT(7)
+#define   MTK_PPE_TB_CFG_SMA_FWD_CPU		(0x3 << 4)
+#define   MTK_PPE_TB_CFG_SMA_MASK		(0x3 << 4)
+#define   MTK_PPE_TB_CFG_ENTRY_SZ_64B		0
+#define   MTK_PPE_TB_CFG_ENTRY_SZ_MASK		BIT(3)
+#define   MTK_PPE_TB_CFG_TBL_SZ_4K		2
+#define   MTK_PPE_TB_CFG_TBL_SZ_MASK		0x7
+
+#define MTK_REG_PPE_HASH_SEED			0xe44
+#define   MTK_PPE_HASH_SEED			0x12345678
+
+
+#define MTK_REG_PPE_CAH_CTRL			0xf20
+#define   MTK_PPE_CAH_CTRL_X_MODE		BIT(9)
+#define   MTK_PPE_CAH_CTRL_EN			BIT(0)
+
+struct mtk_foe_unbind_info_blk {
+	u32 time_stamp:8;
+	u32 pcnt:16;		/* packet count */
+	u32 preb:1;
+	u32 pkt_type:3;
+	u32 state:2;
+	u32 udp:1;
+	u32 sta:1;		/* static entry */
+} __attribute__ ((packed));
+
+struct mtk_foe_bind_info_blk {
+	u32 time_stamp:15;
+	u32 ka:1;		/* keep alive */
+	u32 vlan_layer:3;
+	u32 psn:1;		/* egress packet has PPPoE session */
+#ifdef CONFIG_RALINK
+	u32 vpm:2;		/* 0:ethertype remark, 1:0x8100(CR default) */
+#else
+	u32 vpm:1;		/* 0:ethertype remark, 1:0x8100(CR default) */
+	u32 ps:1;		/* packet sampling */
+#endif
+	u32 cah:1;		/* cacheable flag */
+	u32 rmt:1;		/* remove tunnel ip header (6rd/dslite only) */
+	u32 ttl:1;
+	u32 pkt_type:3;
+	u32 state:2;
+	u32 udp:1;
+	u32 sta:1;		/* static entry */
+} __attribute__ ((packed));
+
+struct mtk_foe_info_blk2 {
+	u32 qid:4;		/* QID in Qos Port */
+	u32 fqos:1;		/* force to PSE QoS port */
+	u32 dp:3;		/* force to PSE port x 
+				 0:PSE,1:GSW, 2:GMAC,4:PPE,5:QDMA,7=DROP */
+	u32 mcast:1;		/* multicast this packet to CPU */
+	u32 pcpl:1;		/* OSBN */
+	u32 mlen:1;		/* 0:post 1:pre packet length in meter */
+	u32 alen:1;		/* 0:post 1:pre packet length in accounting */
+	u32 port_mg:6;		/* port meter group */
+	u32 port_ag:6;		/* port account group */
+	u32 dscp:8;		/* DSCP value */
+} __attribute__ ((packed));
+
+struct mtk_foe_ipv4_hnapt {
+	union {
+		struct mtk_foe_bind_info_blk bfib1;
+		struct mtk_foe_unbind_info_blk udib1;
+		u32 info_blk1;
+	};
+	u32 sip;
+	u32 dip;
+	u16 dport;
+	u16 sport;
+	union {
+		struct mtk_foe_info_blk2 iblk2;
+		u32 info_blk2;
+	};
+	u32 new_sip;
+	u32 new_dip;
+	u16 new_dport;
+	u16 new_sport;
+	u32 resv1;
+	u32 resv2;
+	u32 resv3:26;
+	u32 act_dp:6;		/* UDF */
+	u16 vlan1;
+	u16 etype;
+	u32 dmac_hi;
+	u16 vlan2;
+	u16 dmac_lo;
+	u32 smac_hi;
+	u16 pppoe_id;
+	u16 smac_lo;
+} __attribute__ ((packed));
+
+struct mtk_foe_entry {
+	union {
+		struct mtk_foe_unbind_info_blk udib1;
+		struct mtk_foe_bind_info_blk bfib1;
+		struct mtk_foe_ipv4_hnapt ipv4_hnapt;
+	};
+};
+
+enum mtk_foe_entry_state {
+	FOE_STATE_INVALID = 0,
+	FOE_STATE_UNBIND = 1,
+	FOE_STATE_BIND = 2,
+	FOE_STATE_FIN = 3
+};
+
+
+#define MTK_RXD4_FOE_ENTRY		GENMASK(13, 0)
+#define MTK_RXD4_CPU_REASON		GENMASK(18, 14)
+#define MTK_RXD4_SRC_PORT		GENMASK(21, 19)
+#define MTK_RXD4_ALG			GENMASK(31, 22)
+
+enum mtk_foe_cpu_reason {
+	MTK_CPU_REASON_TTL_EXCEEDED		= 0x02,
+	MTK_CPU_REASON_OPTION_HEADER		= 0x03,
+	MTK_CPU_REASON_NO_FLOW			= 0x07,
+	MTK_CPU_REASON_IPV4_FRAG		= 0x08,
+	MTK_CPU_REASON_IPV4_DSLITE_FRAG		= 0x09,
+	MTK_CPU_REASON_IPV4_DSLITE_NO_TCP_UDP	= 0x0a,
+	MTK_CPU_REASON_IPV6_6RD_NO_TCP_UDP	= 0x0b,
+	MTK_CPU_REASON_TCP_FIN_SYN_RST		= 0x0c,
+	MTK_CPU_REASON_UN_HIT			= 0x0d,
+	MTK_CPU_REASON_HIT_UNBIND		= 0x0e,
+	MTK_CPU_REASON_HIT_UNBIND_RATE_REACHED	= 0x0f,
+	MTK_CPU_REASON_HIT_BIND_TCP_FIN		= 0x10,
+	MTK_CPU_REASON_HIT_TTL_1		= 0x11,
+	MTK_CPU_REASON_HIT_BIND_VLAN_VIOLATION	= 0x12,
+	MTK_CPU_REASON_KEEPALIVE_UC_OLD_HDR	= 0x13,
+	MTK_CPU_REASON_KEEPALIVE_MC_NEW_HDR	= 0x14,
+	MTK_CPU_REASON_KEEPALIVE_DUP_OLD_HDR	= 0x15,
+	MTK_CPU_REASON_HIT_BIND_FORCE_CPU	= 0x16,
+	MTK_CPU_REASON_TUNNEL_OPTION_HEADER	= 0x17,
+	MTK_CPU_REASON_MULTICAST_TO_CPU		= 0x18,
+	MTK_CPU_REASON_MULTICAST_TO_GMAC1_CPU	= 0x19,
+	MTK_CPU_REASON_HIT_PRE_BIND		= 0x1a,
+	MTK_CPU_REASON_PACKET_SAMPLING		= 0x1b,
+	MTK_CPU_REASON_EXCEED_MTU		= 0x1c,
+	MTK_CPU_REASON_PPE_BYPASS		= 0x1e,
+	MTK_CPU_REASON_INVALID			= 0x1f,
+};
+
+
+/* our table size is 4K */
+#define MTK_PPE_ENTRY_CNT		0x1000
+#define MTK_PPE_TBL_SZ			\
+			(MTK_PPE_ENTRY_CNT * sizeof(struct mtk_foe_entry))
+
+int ra_ppe_debugfs_init(struct mtk_eth *eth);
+
+

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/soc_mt7620.c
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/soc_mt7620.c
@@ -27,9 +27,16 @@
 
 #define MT7620A_CDMA_CSG_CFG	0x400
 #define MT7620_DMA_VID		(MT7620A_CDMA_CSG_CFG | 0x30)
+#define MT7621_CDMP_IG_CTRL	(MT7620A_CDMA_CSG_CFG + 0x00)
+#define MT7621_CDMP_EG_CTRL	(MT7620A_CDMA_CSG_CFG + 0x04)
+#define MT7620A_RESET_FE	BIT(21)
+#define MT7621_RESET_FE		BIT(6)
+#define MT7620A_RESET_ESW	BIT(23)
 #define MT7620_L4_VALID		BIT(23)
+#define MT7621_L4_VALID		BIT(24)
 
 #define MT7620_TX_DMA_UDF	BIT(15)
+#define MT7621_TX_DMA_UDF	BIT(19)
 #define TX_DMA_FP_BMAP		((0xff) << 19)
 
 #define CDMA_ICS_EN		BIT(2)
@@ -46,6 +53,11 @@
 #define MT7620_GDM1_TX_GBCNT	(MT7620_REG_MIB_OFFSET + 0x300)
 #define MT7620_GDM2_TX_GBCNT	(MT7620_GDM1_TX_GBCNT + 0x40)
 
+#define MT7621_REG_MIB_OFFSET	0x2000
+#define MT7621_PPE_AC_BCNT0	(MT7621_REG_MIB_OFFSET + 0x00)
+#define MT7621_GDM1_TX_GBCNT	(MT7621_REG_MIB_OFFSET + 0x400)
+#define MT7621_GDM2_TX_GBCNT	(MT7621_GDM1_TX_GBCNT + 0x40)
+
 #define GSW_REG_GDMA1_MAC_ADRL	0x508
 #define GSW_REG_GDMA1_MAC_ADRH	0x50C
 
@@ -56,6 +68,8 @@
  * but after test it should be BIT(13).
  */
 #define MT7620_FE_GDM1_AF	BIT(13)
+#define MT7621_FE_GDM1_AF	BIT(28)
+#define MT7621_FE_GDM2_AF	BIT(29)
 
 static const u16 mt7620_reg_table[FE_REG_COUNT] = {
 	[FE_REG_PDMA_GLO_CFG] = RT5350_PDMA_GLO_CFG,
@@ -80,26 +94,11 @@
 static int mt7620_gsw_config(struct fe_priv *priv)
 {
 	struct mt7620_gsw *gsw = (struct mt7620_gsw *) priv->soc->swpriv;
-	u32 val;
 
 	/* is the mt7530 internal or external */
 	if (priv->mii_bus && mdiobus_get_phy(priv->mii_bus, 0x1f)) {
 		mt7530_probe(priv->dev, gsw->base, NULL, 0);
 		mt7530_probe(priv->dev, NULL, priv->mii_bus, 1);
-
-		/* magic values from original SDK */
-		val = mt7530_mdio_r32(gsw, 0x7830);
-		val &= ~BIT(0);
-		val |= BIT(1);
-		mt7530_mdio_w32(gsw, 0x7830, val);
-
-		val = mt7530_mdio_r32(gsw, 0x7a40);
-		val &= ~BIT(30);
-		mt7530_mdio_w32(gsw, 0x7a40, val);
-
-		mt7530_mdio_w32(gsw, 0x7a78, 0x855);
-
-		pr_info("mt7530: mdio central align\n");
 	} else {
 		mt7530_probe(priv->dev, gsw->base, NULL, 1);
 	}
@@ -154,7 +153,7 @@
 	u32 val, mask = 0;
 	u32 val_delay = 0;
 	u32 mask_delay = GSW_REG_GPCx_TXDELAY | GSW_REG_GPCx_RXDELAY;
-	int min = (gsw->port4_ephy) ? (5) : (4);
+	int min = (gsw->port4 == PORT4_EPHY) ? (5) : (4);
 
 	if (!_id || (be32_to_cpu(*_id) < min) || (be32_to_cpu(*_id) > 5)) {
 		if (_id)
@@ -176,6 +175,7 @@
 	    (size != (4 * sizeof(*priv->phy->phy_fixed[id])))) {
 		pr_err("%s: invalid fixed link property\n", np->name);
 		priv->phy->phy_fixed[id] = NULL;
+		return;
 	}
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)
@@ -203,7 +203,7 @@
 		break;
 	case PHY_INTERFACE_MODE_RGMII_TXID:
 		mask = 0;
-		val_delay |= GSW_REG_GPCx_TXDELAY;
+		val_delay &= ~GSW_REG_GPCx_TXDELAY;
 		val_delay |= GSW_REG_GPCx_RXDELAY;
 		break;
 	case PHY_INTERFACE_MODE_MII:
@@ -217,6 +217,10 @@
 		return;
 	}
 
+	priv->phy->phy_node[id] = of_parse_phandle(np, "phy-handle", 0);
+	if (!priv->phy->phy_node[id] && !priv->phy->phy_fixed[id])
+		return;
+
 	val = rt_sysc_r32(SYSC_REG_CFG1);
 	val &= ~(3 << shift);
 	val |= mask << shift;
@@ -257,8 +261,8 @@
 			val = 2;
 			break;
 		default:
-			dev_err(priv->dev, "port %d - invalid link speed: %d\n",
-				id, priv->phy->speed[id]);
+			dev_err(priv->dev, "invalid link speed: %d\n",
+				priv->phy->speed[id]);
 			priv->phy->phy_fixed[id] = 0;
 			return;
 		}
@@ -272,13 +276,7 @@
 		if (priv->phy->duplex[id])
 			val |= PMCR_DUPLEX;
 		mtk_switch_w32(gsw, val, GSW_REG_PORT_PMCR(id));
-		dev_info(priv->dev, "port %d - using fixed link parameters\n", id);
-		return;
-	}
-
-	priv->phy->phy_node[id] = of_parse_phandle(np, "phy-handle", 0);
-	if (!priv->phy->phy_node[id]) {
-		dev_err(priv->dev, "port %d - missing phy handle\n", id);
+		dev_info(priv->dev, "using fixed link parameters\n");
 		return;
 	}
 
@@ -291,10 +289,11 @@
 		fe_connect_phy_node(priv, priv->phy->phy_node[id], id);
 		gsw->autopoll |= BIT(be32_to_cpup(phy_addr));
 		mt7620_auto_poll(gsw,id);
+		return;
 	}
 }
 
-static void mt7620_fe_reset(struct fe_priv *priv)
+static void mt7620_fe_reset(void)
 {
 	fe_reset(MT7620A_RESET_FE | MT7620A_RESET_ESW);
 }

--- /dev/null
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/soc_mt7621.c
@@ -0,0 +1,187 @@
+/*   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; version 2 of the License
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
+ *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
+ *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/if_vlan.h>
+#include <linux/of_net.h>
+
+#include <asm/mach-ralink/ralink_regs.h>
+
+#include "mtk_eth_soc.h"
+#include "gsw_mt7620.h"
+#include "mt7530.h"
+#include "mdio.h"
+
+#define MT7620A_CDMA_CSG_CFG	0x400
+#define MT7621_CDMP_IG_CTRL	(MT7620A_CDMA_CSG_CFG + 0x00)
+#define MT7621_CDMP_EG_CTRL	(MT7620A_CDMA_CSG_CFG + 0x04)
+#define MT7621_RESET_FE		BIT(6)
+#define MT7621_L4_VALID		BIT(24)
+
+#define MT7621_TX_DMA_UDF	BIT(19)
+#define MT7621_TX_DMA_FPORT	BIT(25)
+
+#define CDMA_ICS_EN		BIT(2)
+#define CDMA_UCS_EN		BIT(1)
+#define CDMA_TCS_EN		BIT(0)
+
+#define GDMA_ICS_EN		BIT(22)
+#define GDMA_TCS_EN		BIT(21)
+#define GDMA_UCS_EN		BIT(20)
+
+/* frame engine counters */
+#define MT7621_REG_MIB_OFFSET	0x2000
+#define MT7621_PPE_AC_BCNT0	(MT7621_REG_MIB_OFFSET + 0x00)
+#define MT7621_GDM1_TX_GBCNT	(MT7621_REG_MIB_OFFSET + 0x400)
+#define MT7621_GDM2_TX_GBCNT	(MT7621_GDM1_TX_GBCNT + 0x40)
+
+#define GSW_REG_GDMA1_MAC_ADRL	0x508
+#define GSW_REG_GDMA1_MAC_ADRH	0x50C
+
+#define MT7621_FE_RST_GL	(FE_FE_OFFSET + 0x04)
+#define MT7620_FE_INT_STATUS2	(FE_FE_OFFSET + 0x08)
+
+/* FE_INT_STATUS reg on mt7620 define CNT_GDM1_AF at BIT(29)
+ * but after test it should be BIT(13).
+ */
+#define MT7620_FE_GDM1_AF	BIT(13)
+#define MT7621_FE_GDM1_AF	BIT(28)
+#define MT7621_FE_GDM2_AF	BIT(29)
+
+static const u16 mt7621_reg_table[FE_REG_COUNT] = {
+	[FE_REG_PDMA_GLO_CFG] = RT5350_PDMA_GLO_CFG,
+	[FE_REG_PDMA_RST_CFG] = RT5350_PDMA_RST_CFG,
+	[FE_REG_DLY_INT_CFG] = RT5350_DLY_INT_CFG,
+	[FE_REG_TX_BASE_PTR0] = RT5350_TX_BASE_PTR0,
+	[FE_REG_TX_MAX_CNT0] = RT5350_TX_MAX_CNT0,
+	[FE_REG_TX_CTX_IDX0] = RT5350_TX_CTX_IDX0,
+	[FE_REG_TX_DTX_IDX0] = RT5350_TX_DTX_IDX0,
+	[FE_REG_RX_BASE_PTR0] = RT5350_RX_BASE_PTR0,
+	[FE_REG_RX_MAX_CNT0] = RT5350_RX_MAX_CNT0,
+	[FE_REG_RX_CALC_IDX0] = RT5350_RX_CALC_IDX0,
+	[FE_REG_RX_DRX_IDX0] = RT5350_RX_DRX_IDX0,
+	[FE_REG_FE_INT_ENABLE] = RT5350_FE_INT_ENABLE,
+	[FE_REG_FE_INT_STATUS] = RT5350_FE_INT_STATUS,
+	[FE_REG_FE_DMA_VID_BASE] = 0,
+	[FE_REG_FE_COUNTER_BASE] = MT7621_GDM1_TX_GBCNT,
+	[FE_REG_FE_RST_GL] = MT7621_FE_RST_GL,
+	[FE_REG_FE_INT_STATUS2] = MT7620_FE_INT_STATUS2,
+};
+
+static int mt7621_gsw_config(struct fe_priv *priv)
+{
+	if (priv->mii_bus &&  mdiobus_get_phy(priv->mii_bus, 0x1f))
+		mt7530_probe(priv->dev, NULL, priv->mii_bus, 1);
+
+	return 0;
+}
+
+static void mt7621_fe_reset(void)
+{
+	fe_reset(MT7621_RESET_FE);
+}
+
+static void mt7621_rxcsum_config(bool enable)
+{
+	if (enable)
+		fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) | (GDMA_ICS_EN |
+					GDMA_TCS_EN | GDMA_UCS_EN),
+				MT7620A_GDMA1_FWD_CFG);
+	else
+		fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) & ~(GDMA_ICS_EN |
+					GDMA_TCS_EN | GDMA_UCS_EN),
+				MT7620A_GDMA1_FWD_CFG);
+}
+
+static void mt7621_rxvlan_config(bool enable)
+{
+	if (enable)
+		fe_w32(1, MT7621_CDMP_EG_CTRL);
+	else
+		fe_w32(0, MT7621_CDMP_EG_CTRL);
+}
+
+static int mt7621_fwd_config(struct fe_priv *priv)
+{
+	struct net_device *dev = priv_netdev(priv);
+
+	fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) & ~0xffff,
+	       MT7620A_GDMA1_FWD_CFG);
+
+	/* mt7621 doesn't have txcsum config */
+	mt7621_rxcsum_config((dev->features & NETIF_F_RXCSUM));
+	mt7621_rxvlan_config(dev->features & NETIF_F_HW_VLAN_CTAG_RX);
+
+	return 0;
+}
+
+static void mt7621_tx_dma(struct fe_tx_dma *txd)
+{
+	txd->txd4 = MT7621_TX_DMA_FPORT;
+}
+
+static void mt7621_init_data(struct fe_soc_data *data,
+			     struct net_device *netdev)
+{
+	struct fe_priv *priv = netdev_priv(netdev);
+
+	priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_RX_2B_OFFSET |
+		FE_FLAG_RX_SG_DMA | FE_FLAG_NAPI_WEIGHT |
+		FE_FLAG_HAS_SWITCH | FE_FLAG_JUMBO_FRAME;
+
+	netdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM |
+		NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |
+		NETIF_F_SG | NETIF_F_TSO |
+		NETIF_F_TSO6 | NETIF_F_IPV6_CSUM |
+		NETIF_F_TSO_MANGLEID;
+}
+
+static void mt7621_set_mac(struct fe_priv *priv, unsigned char *mac)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->page_lock, flags);
+	fe_w32((mac[0] << 8) | mac[1], GSW_REG_GDMA1_MAC_ADRH);
+	fe_w32((mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5],
+	       GSW_REG_GDMA1_MAC_ADRL);
+	spin_unlock_irqrestore(&priv->page_lock, flags);
+}
+
+static struct fe_soc_data mt7621_data = {
+	.init_data = mt7621_init_data,
+	.reset_fe = mt7621_fe_reset,
+	.set_mac = mt7621_set_mac,
+	.fwd_config = mt7621_fwd_config,
+	.tx_dma = mt7621_tx_dma,
+	.switch_init = mtk_gsw_init,
+	.switch_config = mt7621_gsw_config,
+	.reg_table = mt7621_reg_table,
+	.pdma_glo_cfg = FE_PDMA_SIZE_16DWORDS,
+	.rx_int = RT5350_RX_DONE_INT,
+	.tx_int = RT5350_TX_DONE_INT,
+	.status_int = (MT7621_FE_GDM1_AF | MT7621_FE_GDM2_AF),
+	.checksum_bit = MT7621_L4_VALID,
+	.has_carrier = mt7620_has_carrier,
+	.mdio_read = mt7620_mdio_read,
+	.mdio_write = mt7620_mdio_write,
+	.mdio_adjust_link = mt7620_mdio_link_adjust,
+};
+
+const struct of_device_id of_fe_match[] = {
+	{ .compatible = "mediatek,ralink-mt7621-eth", .data = &mt7621_data },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, of_fe_match);

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/soc_rt2880.c
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/soc_rt2880.c
@@ -19,6 +19,8 @@
 #include "mtk_eth_soc.h"
 #include "mdio_rt2880.h"
 
+#define RT2880_RESET_FE			BIT(18)
+
 static void rt2880_init_data(struct fe_soc_data *data,
 			     struct net_device *netdev)
 {
@@ -31,6 +33,11 @@
 	/* netdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_RXCSUM; */
 }
 
+void rt2880_fe_reset(void)
+{
+	fe_reset(RT2880_RESET_FE);
+}
+
 static int rt2880_fwd_config(struct fe_priv *priv)
 {
 	int ret;
@@ -48,6 +55,7 @@
 
 struct fe_soc_data rt2880_data = {
 	.init_data = rt2880_init_data,
+	.reset_fe = rt2880_fe_reset,
 	.fwd_config = rt2880_fwd_config,
 	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
 	.checksum_bit = RX_DMA_L4VALID,

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/soc_rt3050.c
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/soc_rt3050.c
@@ -17,9 +17,11 @@
 #include <asm/mach-ralink/ralink_regs.h>
 
 #include "mtk_eth_soc.h"
-#include "esw_rt3050.h"
 #include "mdio_rt2880.h"
 
+#define RT305X_RESET_FE         BIT(21)
+#define RT305X_RESET_ESW        BIT(23)
+
 static const u16 rt5350_reg_table[FE_REG_COUNT] = {
 	[FE_REG_PDMA_GLO_CFG] = RT5350_PDMA_GLO_CFG,
 	[FE_REG_PDMA_RST_CFG] = RT5350_PDMA_RST_CFG,
@@ -67,6 +69,11 @@
 	return 0;
 }
 
+static void rt305x_fe_reset(void)
+{
+	fe_reset(RT305X_RESET_FE);
+}
+
 static void rt5350_init_data(struct fe_soc_data *data,
 			     struct net_device *netdev)
 {
@@ -113,10 +120,15 @@
 	txd->txd4 = 0;
 }
 
+static void rt5350_fe_reset(void)
+{
+	fe_reset(RT305X_RESET_FE | RT305X_RESET_ESW);
+}
+
 static struct fe_soc_data rt3050_data = {
 	.init_data = rt305x_init_data,
+	.reset_fe = rt305x_fe_reset,
 	.fwd_config = rt3050_fwd_config,
-	.switch_init = rt3050_esw_init,
 	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
 	.checksum_bit = RX_DMA_L4VALID,
 	.rx_int = FE_RX_DONE_INT,
@@ -127,9 +139,9 @@
 static struct fe_soc_data rt5350_data = {
 	.init_data = rt5350_init_data,
 	.reg_table = rt5350_reg_table,
+	.reset_fe = rt5350_fe_reset,
 	.set_mac = rt5350_set_mac,
 	.fwd_config = rt5350_fwd_config,
-	.switch_init = rt3050_esw_init,
 	.tx_dma = rt5350_tx_dma,
 	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
 	.checksum_bit = RX_DMA_L4VALID,

--- a/target/linux/ramips/files/drivers/net/ethernet/ralink/soc_rt3883.c
+++ b/target/linux/ramips/files/drivers/net/ethernet/ralink/soc_rt3883.c
@@ -19,6 +19,13 @@
 #include "mtk_eth_soc.h"
 #include "mdio_rt2880.h"
 
+#define RT3883_RSTCTRL_FE		BIT(21)
+
+static void rt3883_fe_reset(void)
+{
+	fe_reset(RT3883_RSTCTRL_FE);
+}
+
 static int rt3883_fwd_config(struct fe_priv *priv)
 {
 	int ret;
@@ -47,6 +54,7 @@
 
 static struct fe_soc_data rt3883_data = {
 	.init_data = rt3883_init_data,
+	.reset_fe = rt3883_fe_reset,
 	.fwd_config = rt3883_fwd_config,
 	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
 	.rx_int = FE_RX_DONE_INT,

--- a/target/linux/ramips/image/mt7621.mk
+++ b/target/linux/ramips/image/mt7621.mk
@@ -1561,6 +1561,24 @@
 endef
 TARGET_DEVICES += xiaomi_mi-router-4a-gigabit
 
+define Device/xiaomi-ac2100
+  $(Device/uimage-lzma-loader)
+  BLOCKSIZE := 128k
+  PAGESIZE := 2048
+  KERNEL_SIZE := 4096k
+  IMAGE_SIZE := 120320k
+  UBINIZE_OPTS := -E 5
+  IMAGES += kernel1.bin rootfs0.bin factory.bin breed-factory.bin
+  IMAGE/kernel1.bin := append-kernel
+  IMAGE/rootfs0.bin := append-ubi | check-size
+  IMAGE/sysupgrade.bin := sysupgrade-tar | append-metadata
+  IMAGE/factory.bin := append-kernel | pad-to $$(KERNEL_SIZE) | append-ubi | check-size
+  IMAGE/breed-factory.bin := append-kernel | pad-to $$(KERNEL_SIZE) | \
+			     append-kernel | pad-to $$(KERNEL_SIZE) | append-ubi | check-size
+  DEVICE_VENDOR := Xiaomi
+  DEVICE_PACKAGES := kmod-mt7603e kmod-mt7615d luci-app-mtwifi uboot-envtools
+endef
+
 define Device/xiaomi_mi-router-ac2100
   $(Device/xiaomi_nand_separate)
   DEVICE_MODEL := Mi Router AC2100
@@ -1570,10 +1588,8 @@
 TARGET_DEVICES += xiaomi_mi-router-ac2100
 
 define Device/xiaomi_redmi-router-ac2100
-  $(Device/xiaomi_nand_separate)
+  $(Device/xiaomi-ac2100)
   DEVICE_MODEL := Redmi Router AC2100
-  IMAGE_SIZE := 120320k
-  DEVICE_PACKAGES += kmod-mt7603 kmod-mt7615e kmod-mt7615-firmware
 endef
 TARGET_DEVICES += xiaomi_redmi-router-ac2100
 

--- a/target/linux/ramips/mt7621/base-files/etc/board.d/01_leds
+++ b/target/linux/ramips/mt7621/base-files/etc/board.d/01_leds
@@ -117,7 +117,7 @@
 	ucidef_set_led_netdev "wan-blue" "WAN (blue)" "blue:wan" "wan"
 	;;
 xiaomi,redmi-router-ac2100)
-	ucidef_set_led_netdev "wan" "wan" "white:wan" "wan"
+	ucidef_set_led_switch "wan" "wan" "white:wan" "switch0" "0x1"
 	;;
 youhua,wr1200js)
 	ucidef_set_led_netdev "internet" "INTERNET" "green:wan" "wan"

--- a/target/linux/ramips/mt7621/base-files/etc/board.d/02_network
+++ b/target/linux/ramips/mt7621/base-files/etc/board.d/02_network
@@ -27,7 +27,8 @@
 	xiaomi,mi-router-3-pro|\
 	xiaomi,mi-router-ac2100|\
 	xiaomi,redmi-router-ac2100)
-		ucidef_set_interfaces_lan_wan "lan1 lan2 lan3" "wan"
+		ucidef_add_switch "switch0" "2:lan:1" "3:lan:2" "4:lan:3" "0:wan" "6t@eth0"
+		ucidef_set_interface_lan "eth0.1 ra0 rai0"
 		;;
 	asiarf,ap7621-001|\
 	winstars,ws-wn583a6)
@@ -157,6 +158,10 @@
 		wan_mac=$label_mac
 		lan_mac=$(macaddr_add $label_mac 1)
 		;;
+	xiaomi,redmi-router-ac2100)
+		lan_mac=$(cat /sys/class/net/eth0/address)
+		wan_mac=$(mtd_get_mac_binary factory 0xe000)
+		;;
 	esac
 
 	[ -n "$lan_mac" ] && ucidef_set_interface_macaddr "lan" $lan_mac

--- a/target/linux/ramips/mt7621/config-5.4
+++ b/target/linux/ramips/mt7621/config-5.4
@@ -88,6 +88,7 @@
 CONFIG_GPIO_GENERIC=y
 CONFIG_GPIO_MT7621=y
 # CONFIG_GPIO_RALINK is not set
+CONFIG_GPIO_SYSFS=y
 CONFIG_GPIO_WATCHDOG=y
 # CONFIG_GPIO_WATCHDOG_ARCH_INITCALL is not set
 CONFIG_GRO_CELLS=y
@@ -176,11 +177,16 @@
 CONFIG_NET_DSA_TAG_MTK=y
 CONFIG_NET_FLOW_LIMIT=y
 CONFIG_NET_MEDIATEK_SOC=y
+CONFIG_NET_RALINK_GSW_MT7621=y
+CONFIG_NET_RALINK_MDIO=y
+CONFIG_NET_RALINK_MDIO_MT7620=y
+CONFIG_NET_RALINK_MT7621=y
+CONFIG_NET_RALINK_OFFLOAD=y
+CONFIG_NET_RALINK_SOC=y
 CONFIG_NET_SWITCHDEV=y
 CONFIG_NET_VENDOR_MEDIATEK=y
-# CONFIG_NET_VENDOR_RALINK is not set
+CONFIG_NET_VENDOR_RALINK=y
 CONFIG_NR_CPUS=4
-CONFIG_NVMEM=y
 CONFIG_OF=y
 CONFIG_OF_ADDRESS=y
 CONFIG_OF_EARLY_FLATTREE=y
@@ -249,6 +255,8 @@
 CONFIG_SPI_MT7621=y
 # CONFIG_SPI_RT2880 is not set
 CONFIG_SRCU=y
+CONFIG_SWCONFIG=y
+CONFIG_SWCONFIG_LEDS=y
 CONFIG_SWPHY=y
 CONFIG_SYNC_R4K=y
 CONFIG_SYSCTL_EXCEPTION_TRACE=y
